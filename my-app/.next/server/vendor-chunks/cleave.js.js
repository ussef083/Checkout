/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cleave.js";
exports.ids = ["vendor-chunks/cleave.js"];
exports.modules = {

/***/ "(ssr)/../node_modules/cleave.js/dist/cleave-react-node.js":
/*!***********************************************************!*\
  !*** ../node_modules/cleave.js/dist/cleave-react-node.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ // The require function\n        /******/ function __nested_webpack_require_639__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ exports: {},\n                /******/ id: moduleId,\n                /******/ loaded: false\n            };\n            /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_639__);\n            /******/ // Flag the module as loaded\n            /******/ module1.loaded = true;\n            /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_639__.m = modules;\n        /******/ // expose the module cache\n        /******/ __nested_webpack_require_639__.c = installedModules;\n        /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_639__.p = \"\";\n        /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_639__(0);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_1964__) {\n            \"use strict\";\n            var _extends = Object.assign || function(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i];\n                    for(var key in source){\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n                return target;\n            };\n            function _objectWithoutProperties(obj, keys) {\n                var target = {};\n                for(var i in obj){\n                    if (keys.indexOf(i) >= 0) continue;\n                    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                    target[i] = obj[i];\n                }\n                return target;\n            }\n            var React = __nested_webpack_require_1964__(1); // eslint-disable-line no-unused-vars\n            var CreateReactClass = __nested_webpack_require_1964__(2);\n            var NumeralFormatter = __nested_webpack_require_1964__(9);\n            var DateFormatter = __nested_webpack_require_1964__(10);\n            var TimeFormatter = __nested_webpack_require_1964__(11);\n            var PhoneFormatter = __nested_webpack_require_1964__(12);\n            var CreditCardDetector = __nested_webpack_require_1964__(13);\n            var Util = __nested_webpack_require_1964__(14);\n            var DefaultProperties = __nested_webpack_require_1964__(15);\n            var cleaveReactClass = CreateReactClass({\n                componentDidMount: function componentDidMount() {\n                    this.init();\n                },\n                componentDidUpdate: function componentDidUpdate(prevProps) {\n                    var owner = this, phoneRegionCode = (owner.props.options || {}).phoneRegionCode, newValue = owner.props.value, pps = owner.properties;\n                    owner.updateRegisteredEvents(owner.props);\n                    if (prevProps.value !== newValue && newValue !== undefined && newValue !== null) {\n                        newValue = newValue.toString();\n                        if (newValue !== owner.properties.result) {\n                            owner.properties.initValue = newValue;\n                            owner.onInput(newValue, true);\n                        }\n                    }\n                    // update phone region code\n                    var prevPhoneRegionCode = (prevProps.options || {}).phoneRegionCode;\n                    if (prevPhoneRegionCode !== phoneRegionCode && phoneRegionCode && phoneRegionCode !== owner.properties.phoneRegionCode) {\n                        owner.properties.phoneRegionCode = phoneRegionCode;\n                        owner.initPhoneFormatter();\n                        owner.onInput(owner.properties.result);\n                    }\n                    Util.setSelection(owner.element, owner.state.cursorPosition, pps.document);\n                },\n                updateRegisteredEvents: function updateRegisteredEvents(props) {\n                    var owner = this, _owner$registeredEven = owner.registeredEvents, onKeyDown = _owner$registeredEven.onKeyDown, onChange = _owner$registeredEven.onChange, onFocus = _owner$registeredEven.onFocus, onBlur = _owner$registeredEven.onBlur, onInit = _owner$registeredEven.onInit;\n                    if (props.onInit && props.onInit !== onInit) owner.registeredEvents.onInit = props.onInit;\n                    if (props.onChange && props.onChange !== onChange) owner.registeredEvents.onChange = props.onChange;\n                    if (props.onFocus && props.onFocus !== onFocus) owner.registeredEvents.onFocus = props.onFocus;\n                    if (props.onBlur && props.onBlur !== onBlur) owner.registeredEvents.onBlur = props.onBlur;\n                    if (props.onKeyDown && props.onKeyDown !== onKeyDown) owner.registeredEvents.onKeyDown = props.onKeyDown;\n                },\n                getInitialState: function getInitialState() {\n                    var owner = this, _owner$props = owner.props, value = _owner$props.value, options = _owner$props.options, onKeyDown = _owner$props.onKeyDown, onChange = _owner$props.onChange, onFocus = _owner$props.onFocus, onBlur = _owner$props.onBlur, onInit = _owner$props.onInit;\n                    owner.registeredEvents = {\n                        onInit: onInit || Util.noop,\n                        onChange: onChange || Util.noop,\n                        onFocus: onFocus || Util.noop,\n                        onBlur: onBlur || Util.noop,\n                        onKeyDown: onKeyDown || Util.noop\n                    };\n                    if (!options) {\n                        options = {};\n                    }\n                    options.initValue = value;\n                    owner.properties = DefaultProperties.assign({}, options);\n                    return {\n                        value: owner.properties.result,\n                        cursorPosition: 0\n                    };\n                },\n                init: function init() {\n                    var owner = this, pps = owner.properties;\n                    // so no need for this lib at all\n                    if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && pps.blocksLength === 0 && !pps.prefix) {\n                        owner.onInput(pps.initValue);\n                        owner.registeredEvents.onInit(owner);\n                        return;\n                    }\n                    pps.maxLength = Util.getMaxLength(pps.blocks);\n                    owner.isAndroid = Util.isAndroid();\n                    owner.initPhoneFormatter();\n                    owner.initDateFormatter();\n                    owner.initTimeFormatter();\n                    owner.initNumeralFormatter();\n                    // avoid touch input field if value is null\n                    // otherwise Firefox will add red box-shadow for <input required />\n                    if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {\n                        owner.onInput(pps.initValue);\n                    }\n                    owner.registeredEvents.onInit(owner);\n                },\n                initNumeralFormatter: function initNumeralFormatter() {\n                    var owner = this, pps = owner.properties;\n                    if (!pps.numeral) {\n                        return;\n                    }\n                    pps.numeralFormatter = new NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);\n                },\n                initTimeFormatter: function initTimeFormatter() {\n                    var owner = this, pps = owner.properties;\n                    if (!pps.time) {\n                        return;\n                    }\n                    pps.timeFormatter = new TimeFormatter(pps.timePattern, pps.timeFormat);\n                    pps.blocks = pps.timeFormatter.getBlocks();\n                    pps.blocksLength = pps.blocks.length;\n                    pps.maxLength = Util.getMaxLength(pps.blocks);\n                },\n                initDateFormatter: function initDateFormatter() {\n                    var owner = this, pps = owner.properties;\n                    if (!pps.date) {\n                        return;\n                    }\n                    pps.dateFormatter = new DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);\n                    pps.blocks = pps.dateFormatter.getBlocks();\n                    pps.blocksLength = pps.blocks.length;\n                    pps.maxLength = Util.getMaxLength(pps.blocks);\n                },\n                initPhoneFormatter: function initPhoneFormatter() {\n                    var owner = this, pps = owner.properties;\n                    if (!pps.phone) {\n                        return;\n                    }\n                    // Cleave.AsYouTypeFormatter should be provided by\n                    // external google closure lib\n                    try {\n                        pps.phoneFormatter = new PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);\n                    } catch (ex) {\n                        throw new Error(\"Please include phone-type-formatter.{country}.js lib\");\n                    }\n                },\n                setRawValue: function setRawValue(value) {\n                    var owner = this, pps = owner.properties;\n                    value = value !== undefined && value !== null ? value.toString() : \"\";\n                    if (pps.numeral) {\n                        value = value.replace(\".\", pps.numeralDecimalMark);\n                    }\n                    pps.postDelimiterBackspace = false;\n                    owner.onChange({\n                        target: {\n                            value: value\n                        },\n                        // Methods to better resemble a SyntheticEvent\n                        stopPropagation: Util.noop,\n                        preventDefault: Util.noop,\n                        persist: Util.noop\n                    });\n                },\n                getRawValue: function getRawValue() {\n                    var owner = this, pps = owner.properties, rawValue = pps.result;\n                    if (pps.rawValueTrimPrefix) {\n                        rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);\n                    }\n                    if (pps.numeral) {\n                        rawValue = pps.numeralFormatter ? pps.numeralFormatter.getRawValue(rawValue) : \"\";\n                    } else {\n                        rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);\n                    }\n                    return rawValue;\n                },\n                getISOFormatDate: function getISOFormatDate() {\n                    var owner = this, pps = owner.properties;\n                    return pps.date ? pps.dateFormatter.getISOFormatDate() : \"\";\n                },\n                getISOFormatTime: function getISOFormatTime() {\n                    var owner = this, pps = owner.properties;\n                    return pps.time ? pps.timeFormatter.getISOFormatTime() : \"\";\n                },\n                onInit: function onInit(owner) {\n                    return owner;\n                },\n                onKeyDown: function onKeyDown(event) {\n                    var owner = this, pps = owner.properties, charCode = event.which || event.keyCode;\n                    owner.lastInputValue = pps.result;\n                    owner.isBackward = charCode === 8;\n                    owner.registeredEvents.onKeyDown(event);\n                },\n                onFocus: function onFocus(event) {\n                    var owner = this, pps = owner.properties;\n                    if (pps.prefix && pps.noImmediatePrefix && !event.target.value) {\n                        owner.onInput(pps.prefix);\n                    }\n                    event.target.rawValue = owner.getRawValue();\n                    event.target.value = pps.result;\n                    owner.registeredEvents.onFocus(event);\n                    Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);\n                },\n                onBlur: function onBlur(event) {\n                    var owner = this, pps = owner.properties;\n                    event.target.rawValue = owner.getRawValue();\n                    event.target.value = pps.result;\n                    owner.registeredEvents.onBlur(event);\n                },\n                onChange: function onChange(event) {\n                    var owner = this, pps = owner.properties;\n                    owner.isBackward = owner.isBackward || event.inputType === \"deleteContentBackward\";\n                    // hit backspace when last character is delimiter\n                    var postDelimiter = Util.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);\n                    if (owner.isBackward && postDelimiter) {\n                        pps.postDelimiterBackspace = postDelimiter;\n                    } else {\n                        pps.postDelimiterBackspace = false;\n                    }\n                    owner.onInput(event.target.value);\n                    event.target.rawValue = owner.getRawValue();\n                    event.target.value = pps.result;\n                    owner.registeredEvents.onChange(event);\n                },\n                onInput: function onInput(value, fromProps) {\n                    var owner = this, pps = owner.properties;\n                    // case 1: delete one more character \"4\"\n                    // 1234*| -> hit backspace -> 123|\n                    // case 2: last character is not delimiter which is:\n                    // 12|34* -> hit backspace -> 1|34*\n                    var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);\n                    if (!fromProps && !pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {\n                        value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);\n                    }\n                    // phone formatter\n                    if (pps.phone) {\n                        if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {\n                            pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);\n                        } else {\n                            pps.result = pps.phoneFormatter.format(value);\n                        }\n                        owner.updateValueState();\n                        return;\n                    }\n                    // numeral formatter\n                    if (pps.numeral) {\n                        // Do not show prefix when noImmediatePrefix is specified\n                        // This mostly because we need to show user the native input placeholder\n                        if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {\n                            pps.result = \"\";\n                        } else {\n                            pps.result = pps.numeralFormatter.format(value);\n                        }\n                        owner.updateValueState();\n                        return;\n                    }\n                    // date\n                    if (pps.date) {\n                        value = pps.dateFormatter.getValidatedDate(value);\n                    }\n                    // time\n                    if (pps.time) {\n                        value = pps.timeFormatter.getValidatedTime(value);\n                    }\n                    // strip delimiters\n                    value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);\n                    // strip prefix\n                    value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);\n                    // strip non-numeric characters\n                    value = pps.numericOnly ? Util.strip(value, /[^\\d]/g) : value;\n                    // convert case\n                    value = pps.uppercase ? value.toUpperCase() : value;\n                    value = pps.lowercase ? value.toLowerCase() : value;\n                    // prevent from showing prefix when no immediate option enabled with empty input value\n                    if (pps.prefix) {\n                        if (pps.tailPrefix) {\n                            value = value + pps.prefix;\n                        } else {\n                            value = pps.prefix + value;\n                        }\n                        // no blocks specified, no need to do formatting\n                        if (pps.blocksLength === 0) {\n                            pps.result = value;\n                            owner.updateValueState();\n                            return;\n                        }\n                    }\n                    // update credit card props\n                    if (pps.creditCard) {\n                        owner.updateCreditCardPropsByValue(value);\n                    }\n                    // strip over length characters\n                    value = pps.maxLength > 0 ? Util.headStr(value, pps.maxLength) : value;\n                    // apply blocks\n                    pps.result = Util.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);\n                    owner.updateValueState();\n                },\n                updateCreditCardPropsByValue: function updateCreditCardPropsByValue(value) {\n                    var owner = this, pps = owner.properties, creditCardInfo;\n                    // At least one of the first 4 characters has changed\n                    if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {\n                        return;\n                    }\n                    creditCardInfo = CreditCardDetector.getInfo(value, pps.creditCardStrictMode);\n                    pps.blocks = creditCardInfo.blocks;\n                    pps.blocksLength = pps.blocks.length;\n                    pps.maxLength = Util.getMaxLength(pps.blocks);\n                    // credit card type changed\n                    if (pps.creditCardType !== creditCardInfo.type) {\n                        pps.creditCardType = creditCardInfo.type;\n                        pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);\n                    }\n                },\n                updateValueState: function updateValueState() {\n                    var owner = this, pps = owner.properties;\n                    if (!owner.element) {\n                        owner.setState({\n                            value: pps.result\n                        });\n                        return;\n                    }\n                    var endPos = owner.element.selectionEnd;\n                    var oldValue = owner.element.value;\n                    var newValue = pps.result;\n                    owner.lastInputValue = newValue;\n                    endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);\n                    if (owner.isAndroid) {\n                        window.setTimeout(function() {\n                            owner.setState({\n                                value: newValue,\n                                cursorPosition: endPos\n                            });\n                        }, 1);\n                        return;\n                    }\n                    owner.setState({\n                        value: newValue,\n                        cursorPosition: endPos\n                    });\n                },\n                render: function render() {\n                    var owner = this;\n                    // eslint-disable-next-line\n                    var _owner$props2 = owner.props, value = _owner$props2.value, options = _owner$props2.options, onKeyDown = _owner$props2.onKeyDown, onFocus = _owner$props2.onFocus, onBlur = _owner$props2.onBlur, onChange = _owner$props2.onChange, onInit = _owner$props2.onInit, htmlRef = _owner$props2.htmlRef, propsToTransfer = _objectWithoutProperties(_owner$props2, [\n                        \"value\",\n                        \"options\",\n                        \"onKeyDown\",\n                        \"onFocus\",\n                        \"onBlur\",\n                        \"onChange\",\n                        \"onInit\",\n                        \"htmlRef\"\n                    ]);\n                    return React.createElement(\"input\", _extends({\n                        type: \"text\",\n                        ref: function ref(_ref) {\n                            owner.element = _ref;\n                            if (!htmlRef) {\n                                return;\n                            }\n                            htmlRef.apply(this, arguments);\n                        },\n                        value: owner.state.value,\n                        onKeyDown: owner.onKeyDown,\n                        onChange: owner.onChange,\n                        onFocus: owner.onFocus,\n                        onBlur: owner.onBlur\n                    }, propsToTransfer));\n                }\n            });\n            module1.exports = cleaveReactClass;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_22658__) {\n            /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */ \"use strict\";\n            var React = __nested_webpack_require_22658__(1);\n            var factory = __nested_webpack_require_22658__(3);\n            if (typeof React === \"undefined\") {\n                throw Error(\"create-react-class could not find the React object. If you are using script tags, \" + \"make sure that React is being loaded before create-react-class.\");\n            }\n            // Hack to grab NoopUpdateQueue from isomorphic React\n            var ReactNoopUpdateQueue = new React.Component().updater;\n            module1.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_23545__) {\n            /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */ \"use strict\";\n            var _assign = __nested_webpack_require_23545__(4);\n            var emptyObject = __nested_webpack_require_23545__(5);\n            var _invariant = __nested_webpack_require_23545__(6);\n            if (true) {\n                var warning = __nested_webpack_require_23545__(7);\n            }\n            var MIXINS_KEY = \"mixins\";\n            // Helper function to allow the creation of anonymous functions which do not\n            // have .name set to the name of the variable being assigned to.\n            function identity(fn) {\n                return fn;\n            }\n            var ReactPropTypeLocationNames;\n            if (true) {\n                ReactPropTypeLocationNames = {\n                    prop: \"prop\",\n                    context: \"context\",\n                    childContext: \"child context\"\n                };\n            } else {}\n            function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {\n                /**\n\t   * Policies that describe methods in `ReactClassInterface`.\n\t   */ var injectedMixins = [];\n                /**\n\t   * Composite components are higher-level components that compose other composite\n\t   * or host components.\n\t   *\n\t   * To create a new type of `ReactClass`, pass a specification of\n\t   * your new class to `React.createClass`. The only requirement of your class\n\t   * specification is that you implement a `render` method.\n\t   *\n\t   *   var MyComponent = React.createClass({\n\t   *     render: function() {\n\t   *       return <div>Hello World</div>;\n\t   *     }\n\t   *   });\n\t   *\n\t   * The class specification supports a specific protocol of methods that have\n\t   * special meaning (e.g. `render`). See `ReactClassInterface` for\n\t   * more the comprehensive protocol. Any other properties and methods in the\n\t   * class specification will be available on the prototype.\n\t   *\n\t   * @interface ReactClassInterface\n\t   * @internal\n\t   */ var ReactClassInterface = {\n                    /**\n\t     * An array of Mixin objects to include when defining your component.\n\t     *\n\t     * @type {array}\n\t     * @optional\n\t     */ mixins: \"DEFINE_MANY\",\n                    /**\n\t     * An object containing properties and methods that should be defined on\n\t     * the component's constructor instead of its prototype (static methods).\n\t     *\n\t     * @type {object}\n\t     * @optional\n\t     */ statics: \"DEFINE_MANY\",\n                    /**\n\t     * Definition of prop types for this component.\n\t     *\n\t     * @type {object}\n\t     * @optional\n\t     */ propTypes: \"DEFINE_MANY\",\n                    /**\n\t     * Definition of context types for this component.\n\t     *\n\t     * @type {object}\n\t     * @optional\n\t     */ contextTypes: \"DEFINE_MANY\",\n                    /**\n\t     * Definition of context types this component sets for its children.\n\t     *\n\t     * @type {object}\n\t     * @optional\n\t     */ childContextTypes: \"DEFINE_MANY\",\n                    // ==== Definition methods ====\n                    /**\n\t     * Invoked when the component is mounted. Values in the mapping will be set on\n\t     * `this.props` if that prop is not specified (i.e. using an `in` check).\n\t     *\n\t     * This method is invoked before `getInitialState` and therefore cannot rely\n\t     * on `this.state` or use `this.setState`.\n\t     *\n\t     * @return {object}\n\t     * @optional\n\t     */ getDefaultProps: \"DEFINE_MANY_MERGED\",\n                    /**\n\t     * Invoked once before the component is mounted. The return value will be used\n\t     * as the initial value of `this.state`.\n\t     *\n\t     *   getInitialState: function() {\n\t     *     return {\n\t     *       isOn: false,\n\t     *       fooBaz: new BazFoo()\n\t     *     }\n\t     *   }\n\t     *\n\t     * @return {object}\n\t     * @optional\n\t     */ getInitialState: \"DEFINE_MANY_MERGED\",\n                    /**\n\t     * @return {object}\n\t     * @optional\n\t     */ getChildContext: \"DEFINE_MANY_MERGED\",\n                    /**\n\t     * Uses props from `this.props` and state from `this.state` to render the\n\t     * structure of the component.\n\t     *\n\t     * No guarantees are made about when or how often this method is invoked, so\n\t     * it must not have side effects.\n\t     *\n\t     *   render: function() {\n\t     *     var name = this.props.name;\n\t     *     return <div>Hello, {name}!</div>;\n\t     *   }\n\t     *\n\t     * @return {ReactComponent}\n\t     * @required\n\t     */ render: \"DEFINE_ONCE\",\n                    // ==== Delegate methods ====\n                    /**\n\t     * Invoked when the component is initially created and about to be mounted.\n\t     * This may have side effects, but any external subscriptions or data created\n\t     * by this method must be cleaned up in `componentWillUnmount`.\n\t     *\n\t     * @optional\n\t     */ componentWillMount: \"DEFINE_MANY\",\n                    /**\n\t     * Invoked when the component has been mounted and has a DOM representation.\n\t     * However, there is no guarantee that the DOM node is in the document.\n\t     *\n\t     * Use this as an opportunity to operate on the DOM when the component has\n\t     * been mounted (initialized and rendered) for the first time.\n\t     *\n\t     * @param {DOMElement} rootNode DOM element representing the component.\n\t     * @optional\n\t     */ componentDidMount: \"DEFINE_MANY\",\n                    /**\n\t     * Invoked before the component receives new props.\n\t     *\n\t     * Use this as an opportunity to react to a prop transition by updating the\n\t     * state using `this.setState`. Current props are accessed via `this.props`.\n\t     *\n\t     *   componentWillReceiveProps: function(nextProps, nextContext) {\n\t     *     this.setState({\n\t     *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n\t     *     });\n\t     *   }\n\t     *\n\t     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n\t     * transition may cause a state change, but the opposite is not true. If you\n\t     * need it, you are probably looking for `componentWillUpdate`.\n\t     *\n\t     * @param {object} nextProps\n\t     * @optional\n\t     */ componentWillReceiveProps: \"DEFINE_MANY\",\n                    /**\n\t     * Invoked while deciding if the component should be updated as a result of\n\t     * receiving new props, state and/or context.\n\t     *\n\t     * Use this as an opportunity to `return false` when you're certain that the\n\t     * transition to the new props/state/context will not require a component\n\t     * update.\n\t     *\n\t     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n\t     *     return !equal(nextProps, this.props) ||\n\t     *       !equal(nextState, this.state) ||\n\t     *       !equal(nextContext, this.context);\n\t     *   }\n\t     *\n\t     * @param {object} nextProps\n\t     * @param {?object} nextState\n\t     * @param {?object} nextContext\n\t     * @return {boolean} True if the component should update.\n\t     * @optional\n\t     */ shouldComponentUpdate: \"DEFINE_ONCE\",\n                    /**\n\t     * Invoked when the component is about to update due to a transition from\n\t     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n\t     * and `nextContext`.\n\t     *\n\t     * Use this as an opportunity to perform preparation before an update occurs.\n\t     *\n\t     * NOTE: You **cannot** use `this.setState()` in this method.\n\t     *\n\t     * @param {object} nextProps\n\t     * @param {?object} nextState\n\t     * @param {?object} nextContext\n\t     * @param {ReactReconcileTransaction} transaction\n\t     * @optional\n\t     */ componentWillUpdate: \"DEFINE_MANY\",\n                    /**\n\t     * Invoked when the component's DOM representation has been updated.\n\t     *\n\t     * Use this as an opportunity to operate on the DOM when the component has\n\t     * been updated.\n\t     *\n\t     * @param {object} prevProps\n\t     * @param {?object} prevState\n\t     * @param {?object} prevContext\n\t     * @param {DOMElement} rootNode DOM element representing the component.\n\t     * @optional\n\t     */ componentDidUpdate: \"DEFINE_MANY\",\n                    /**\n\t     * Invoked when the component is about to be removed from its parent and have\n\t     * its DOM representation destroyed.\n\t     *\n\t     * Use this as an opportunity to deallocate any external resources.\n\t     *\n\t     * NOTE: There is no `componentDidUnmount` since your component will have been\n\t     * destroyed by that point.\n\t     *\n\t     * @optional\n\t     */ componentWillUnmount: \"DEFINE_MANY\",\n                    /**\n\t     * Replacement for (deprecated) `componentWillMount`.\n\t     *\n\t     * @optional\n\t     */ UNSAFE_componentWillMount: \"DEFINE_MANY\",\n                    /**\n\t     * Replacement for (deprecated) `componentWillReceiveProps`.\n\t     *\n\t     * @optional\n\t     */ UNSAFE_componentWillReceiveProps: \"DEFINE_MANY\",\n                    /**\n\t     * Replacement for (deprecated) `componentWillUpdate`.\n\t     *\n\t     * @optional\n\t     */ UNSAFE_componentWillUpdate: \"DEFINE_MANY\",\n                    // ==== Advanced methods ====\n                    /**\n\t     * Updates the component's currently mounted DOM representation.\n\t     *\n\t     * By default, this implements React's rendering and reconciliation algorithm.\n\t     * Sophisticated clients may wish to override this.\n\t     *\n\t     * @param {ReactReconcileTransaction} transaction\n\t     * @internal\n\t     * @overridable\n\t     */ updateComponent: \"OVERRIDE_BASE\"\n                };\n                /**\n\t   * Similar to ReactClassInterface but for static methods.\n\t   */ var ReactClassStaticInterface = {\n                    /**\n\t     * This method is invoked after a component is instantiated and when it\n\t     * receives new props. Return an object to update state in response to\n\t     * prop changes. Return null to indicate no change to state.\n\t     *\n\t     * If an object is returned, its keys will be merged into the existing state.\n\t     *\n\t     * @return {object || null}\n\t     * @optional\n\t     */ getDerivedStateFromProps: \"DEFINE_MANY_MERGED\"\n                };\n                /**\n\t   * Mapping from class specification keys to special processing functions.\n\t   *\n\t   * Although these are declared like instance properties in the specification\n\t   * when defining classes using `React.createClass`, they are actually static\n\t   * and are accessible on the constructor instead of the prototype. Despite\n\t   * being static, they must be defined outside of the \"statics\" key under\n\t   * which all other static methods are defined.\n\t   */ var RESERVED_SPEC_KEYS = {\n                    displayName: function(Constructor, displayName) {\n                        Constructor.displayName = displayName;\n                    },\n                    mixins: function(Constructor, mixins) {\n                        if (mixins) {\n                            for(var i = 0; i < mixins.length; i++){\n                                mixSpecIntoComponent(Constructor, mixins[i]);\n                            }\n                        }\n                    },\n                    childContextTypes: function(Constructor, childContextTypes) {\n                        if (true) {\n                            validateTypeDef(Constructor, childContextTypes, \"childContext\");\n                        }\n                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);\n                    },\n                    contextTypes: function(Constructor, contextTypes) {\n                        if (true) {\n                            validateTypeDef(Constructor, contextTypes, \"context\");\n                        }\n                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);\n                    },\n                    /**\n\t     * Special case getDefaultProps which should move into statics but requires\n\t     * automatic merging.\n\t     */ getDefaultProps: function(Constructor, getDefaultProps) {\n                        if (Constructor.getDefaultProps) {\n                            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n                        } else {\n                            Constructor.getDefaultProps = getDefaultProps;\n                        }\n                    },\n                    propTypes: function(Constructor, propTypes) {\n                        if (true) {\n                            validateTypeDef(Constructor, propTypes, \"prop\");\n                        }\n                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n                    },\n                    statics: function(Constructor, statics) {\n                        mixStaticSpecIntoComponent(Constructor, statics);\n                    },\n                    autobind: function() {}\n                };\n                function validateTypeDef(Constructor, typeDef, location) {\n                    for(var propName in typeDef){\n                        if (typeDef.hasOwnProperty(propName)) {\n                            // use a warning instead of an _invariant so components\n                            // don't show up in prod but only in __DEV__\n                            if (true) {\n                                warning(typeof typeDef[propName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"React.PropTypes.\", Constructor.displayName || \"ReactClass\", ReactPropTypeLocationNames[location], propName);\n                            }\n                        }\n                    }\n                }\n                function validateMethodOverride(isAlreadyDefined, name) {\n                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;\n                    // Disallow overriding of base class methods unless explicitly allowed.\n                    if (ReactClassMixin.hasOwnProperty(name)) {\n                        _invariant(specPolicy === \"OVERRIDE_BASE\", \"ReactClassInterface: You are attempting to override \" + \"`%s` from your class specification. Ensure that your method names \" + \"do not overlap with React methods.\", name);\n                    }\n                    // Disallow defining methods more than once unless explicitly allowed.\n                    if (isAlreadyDefined) {\n                        _invariant(specPolicy === \"DEFINE_MANY\" || specPolicy === \"DEFINE_MANY_MERGED\", \"ReactClassInterface: You are attempting to define \" + \"`%s` on your component more than once. This conflict may be due \" + \"to a mixin.\", name);\n                    }\n                }\n                /**\n\t   * Mixin helper which handles policy validation and reserved\n\t   * specification keys when building React classes.\n\t   */ function mixSpecIntoComponent(Constructor, spec) {\n                    if (!spec) {\n                        if (true) {\n                            var typeofSpec = typeof spec;\n                            var isMixinValid = typeofSpec === \"object\" && spec !== null;\n                            if (true) {\n                                warning(isMixinValid, \"%s: You're attempting to include a mixin that is either null \" + \"or not an object. Check the mixins included by the component, \" + \"as well as any mixins they include themselves. \" + \"Expected object but got %s.\", Constructor.displayName || \"ReactClass\", spec === null ? null : typeofSpec);\n                            }\n                        }\n                        return;\n                    }\n                    _invariant(typeof spec !== \"function\", \"ReactClass: You're attempting to \" + \"use a component class or function as a mixin. Instead, just use a \" + \"regular object.\");\n                    _invariant(!isValidElement(spec), \"ReactClass: You're attempting to \" + \"use a component as a mixin. Instead, just use a regular object.\");\n                    var proto = Constructor.prototype;\n                    var autoBindPairs = proto.__reactAutoBindPairs;\n                    // By handling mixins before any other properties, we ensure the same\n                    // chaining order is applied to methods with DEFINE_MANY policy, whether\n                    // mixins are listed before or after these methods in the spec.\n                    if (spec.hasOwnProperty(MIXINS_KEY)) {\n                        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n                    }\n                    for(var name in spec){\n                        if (!spec.hasOwnProperty(name)) {\n                            continue;\n                        }\n                        if (name === MIXINS_KEY) {\n                            continue;\n                        }\n                        var property = spec[name];\n                        var isAlreadyDefined = proto.hasOwnProperty(name);\n                        validateMethodOverride(isAlreadyDefined, name);\n                        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n                            RESERVED_SPEC_KEYS[name](Constructor, property);\n                        } else {\n                            // Setup methods on prototype:\n                            // The following member methods should not be automatically bound:\n                            // 1. Expected ReactClass methods (in the \"interface\").\n                            // 2. Overridden methods (that were mixed in).\n                            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n                            var isFunction = typeof property === \"function\";\n                            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n                            if (shouldAutoBind) {\n                                autoBindPairs.push(name, property);\n                                proto[name] = property;\n                            } else {\n                                if (isAlreadyDefined) {\n                                    var specPolicy = ReactClassInterface[name];\n                                    // These cases should already be caught by validateMethodOverride.\n                                    _invariant(isReactClassMethod && (specPolicy === \"DEFINE_MANY_MERGED\" || specPolicy === \"DEFINE_MANY\"), \"ReactClass: Unexpected spec policy %s for key %s \" + \"when mixing in component specs.\", specPolicy, name);\n                                    // For methods which are defined more than once, call the existing\n                                    // methods before calling the new property, merging if appropriate.\n                                    if (specPolicy === \"DEFINE_MANY_MERGED\") {\n                                        proto[name] = createMergedResultFunction(proto[name], property);\n                                    } else if (specPolicy === \"DEFINE_MANY\") {\n                                        proto[name] = createChainedFunction(proto[name], property);\n                                    }\n                                } else {\n                                    proto[name] = property;\n                                    if (true) {\n                                        // Add verbose displayName to the function, which helps when looking\n                                        // at profiling tools.\n                                        if (typeof property === \"function\" && spec.displayName) {\n                                            proto[name].displayName = spec.displayName + \"_\" + name;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                function mixStaticSpecIntoComponent(Constructor, statics) {\n                    if (!statics) {\n                        return;\n                    }\n                    for(var name in statics){\n                        var property = statics[name];\n                        if (!statics.hasOwnProperty(name)) {\n                            continue;\n                        }\n                        var isReserved = name in RESERVED_SPEC_KEYS;\n                        _invariant(!isReserved, \"ReactClass: You are attempting to define a reserved \" + 'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' + \"as an instance property instead; it will still be accessible on the \" + \"constructor.\", name);\n                        var isAlreadyDefined = name in Constructor;\n                        if (isAlreadyDefined) {\n                            var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;\n                            _invariant(specPolicy === \"DEFINE_MANY_MERGED\", \"ReactClass: You are attempting to define \" + \"`%s` on your component more than once. This conflict may be \" + \"due to a mixin.\", name);\n                            Constructor[name] = createMergedResultFunction(Constructor[name], property);\n                            return;\n                        }\n                        Constructor[name] = property;\n                    }\n                }\n                /**\n\t   * Merge two objects, but throw if both contain the same key.\n\t   *\n\t   * @param {object} one The first object, which is mutated.\n\t   * @param {object} two The second object\n\t   * @return {object} one after it has been mutated to contain everything in two.\n\t   */ function mergeIntoWithNoDuplicateKeys(one, two) {\n                    _invariant(one && two && typeof one === \"object\" && typeof two === \"object\", \"mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.\");\n                    for(var key in two){\n                        if (two.hasOwnProperty(key)) {\n                            _invariant(one[key] === undefined, \"mergeIntoWithNoDuplicateKeys(): \" + \"Tried to merge two objects with the same key: `%s`. This conflict \" + \"may be due to a mixin; in particular, this may be caused by two \" + \"getInitialState() or getDefaultProps() methods returning objects \" + \"with clashing keys.\", key);\n                            one[key] = two[key];\n                        }\n                    }\n                    return one;\n                }\n                /**\n\t   * Creates a function that invokes two functions and merges their return values.\n\t   *\n\t   * @param {function} one Function to invoke first.\n\t   * @param {function} two Function to invoke second.\n\t   * @return {function} Function that invokes the two argument functions.\n\t   * @private\n\t   */ function createMergedResultFunction(one, two) {\n                    return function mergedResult() {\n                        var a = one.apply(this, arguments);\n                        var b = two.apply(this, arguments);\n                        if (a == null) {\n                            return b;\n                        } else if (b == null) {\n                            return a;\n                        }\n                        var c = {};\n                        mergeIntoWithNoDuplicateKeys(c, a);\n                        mergeIntoWithNoDuplicateKeys(c, b);\n                        return c;\n                    };\n                }\n                /**\n\t   * Creates a function that invokes two functions and ignores their return vales.\n\t   *\n\t   * @param {function} one Function to invoke first.\n\t   * @param {function} two Function to invoke second.\n\t   * @return {function} Function that invokes the two argument functions.\n\t   * @private\n\t   */ function createChainedFunction(one, two) {\n                    return function chainedFunction() {\n                        one.apply(this, arguments);\n                        two.apply(this, arguments);\n                    };\n                }\n                /**\n\t   * Binds a method to the component.\n\t   *\n\t   * @param {object} component Component whose method is going to be bound.\n\t   * @param {function} method Method to be bound.\n\t   * @return {function} The bound method.\n\t   */ function bindAutoBindMethod(component, method) {\n                    var boundMethod = method.bind(component);\n                    if (true) {\n                        boundMethod.__reactBoundContext = component;\n                        boundMethod.__reactBoundMethod = method;\n                        boundMethod.__reactBoundArguments = null;\n                        var componentName = component.constructor.displayName;\n                        var _bind = boundMethod.bind;\n                        boundMethod.bind = function(newThis) {\n                            for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                args[_key - 1] = arguments[_key];\n                            }\n                            // User is trying to bind() an autobound method; we effectively will\n                            // ignore the value of \"this\" that the user is trying to use, so\n                            // let's warn.\n                            if (newThis !== component && newThis !== null) {\n                                if (true) {\n                                    warning(false, \"bind(): React component methods may only be bound to the \" + \"component instance. See %s\", componentName);\n                                }\n                            } else if (!args.length) {\n                                if (true) {\n                                    warning(false, \"bind(): You are binding a component method to the component. \" + \"React does this for you automatically in a high-performance \" + \"way, so you can safely remove this call. See %s\", componentName);\n                                }\n                                return boundMethod;\n                            }\n                            var reboundMethod = _bind.apply(boundMethod, arguments);\n                            reboundMethod.__reactBoundContext = component;\n                            reboundMethod.__reactBoundMethod = method;\n                            reboundMethod.__reactBoundArguments = args;\n                            return reboundMethod;\n                        };\n                    }\n                    return boundMethod;\n                }\n                /**\n\t   * Binds all auto-bound methods in a component.\n\t   *\n\t   * @param {object} component Component whose method is going to be bound.\n\t   */ function bindAutoBindMethods(component) {\n                    var pairs = component.__reactAutoBindPairs;\n                    for(var i = 0; i < pairs.length; i += 2){\n                        var autoBindKey = pairs[i];\n                        var method = pairs[i + 1];\n                        component[autoBindKey] = bindAutoBindMethod(component, method);\n                    }\n                }\n                var IsMountedPreMixin = {\n                    componentDidMount: function() {\n                        this.__isMounted = true;\n                    }\n                };\n                var IsMountedPostMixin = {\n                    componentWillUnmount: function() {\n                        this.__isMounted = false;\n                    }\n                };\n                /**\n\t   * Add more to the ReactClass base class. These are all legacy features and\n\t   * therefore not already part of the modern ReactComponent.\n\t   */ var ReactClassMixin = {\n                    /**\n\t     * TODO: This will be deprecated because state should always keep a consistent\n\t     * type signature and the only use case for this, is to avoid that.\n\t     */ replaceState: function(newState, callback) {\n                        this.updater.enqueueReplaceState(this, newState, callback);\n                    },\n                    /**\n\t     * Checks whether or not this composite component is mounted.\n\t     * @return {boolean} True if mounted, false otherwise.\n\t     * @protected\n\t     * @final\n\t     */ isMounted: function() {\n                        if (true) {\n                            warning(this.__didWarnIsMounted, \"%s: isMounted is deprecated. Instead, make sure to clean up \" + \"subscriptions and pending requests in componentWillUnmount to \" + \"prevent memory leaks.\", this.constructor && this.constructor.displayName || this.name || \"Component\");\n                            this.__didWarnIsMounted = true;\n                        }\n                        return !!this.__isMounted;\n                    }\n                };\n                var ReactClassComponent = function() {};\n                _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n                /**\n\t   * Creates a composite component class given a class specification.\n\t   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n\t   *\n\t   * @param {object} spec Class specification (which must define `render`).\n\t   * @return {function} Component constructor function.\n\t   * @public\n\t   */ function createClass(spec) {\n                    // To keep our warnings more understandable, we'll use a little hack here to\n                    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n                    // unnecessarily identify a class without displayName as 'Constructor'.\n                    var Constructor = identity(function(props, context, updater) {\n                        // This constructor gets overridden by mocks. The argument is used\n                        // by mocks to assert on what gets mounted.\n                        if (true) {\n                            warning(this instanceof Constructor, \"Something is calling a React component directly. Use a factory or \" + \"JSX instead. See: https://fb.me/react-legacyfactory\");\n                        }\n                        // Wire up auto-binding\n                        if (this.__reactAutoBindPairs.length) {\n                            bindAutoBindMethods(this);\n                        }\n                        this.props = props;\n                        this.context = context;\n                        this.refs = emptyObject;\n                        this.updater = updater || ReactNoopUpdateQueue;\n                        this.state = null;\n                        // ReactClasses doesn't have constructors. Instead, they use the\n                        // getInitialState and componentWillMount methods for initialization.\n                        var initialState = this.getInitialState ? this.getInitialState() : null;\n                        if (true) {\n                            // We allow auto-mocks to proceed as if they're returning null.\n                            if (initialState === undefined && this.getInitialState._isMockFunction) {\n                                // This is probably bad practice. Consider warning here and\n                                // deprecating this convenience.\n                                initialState = null;\n                            }\n                        }\n                        _invariant(typeof initialState === \"object\" && !Array.isArray(initialState), \"%s.getInitialState(): must return an object or null\", Constructor.displayName || \"ReactCompositeComponent\");\n                        this.state = initialState;\n                    });\n                    Constructor.prototype = new ReactClassComponent();\n                    Constructor.prototype.constructor = Constructor;\n                    Constructor.prototype.__reactAutoBindPairs = [];\n                    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n                    mixSpecIntoComponent(Constructor, IsMountedPreMixin);\n                    mixSpecIntoComponent(Constructor, spec);\n                    mixSpecIntoComponent(Constructor, IsMountedPostMixin);\n                    // Initialize the defaultProps property after all mixins have been merged.\n                    if (Constructor.getDefaultProps) {\n                        Constructor.defaultProps = Constructor.getDefaultProps();\n                    }\n                    if (true) {\n                        // This is a tag to indicate that the use of these method names is ok,\n                        // since it's used with createClass. If it's not, then it's likely a\n                        // mistake so we'll warn you to use the static property, property\n                        // initializer or constructor respectively.\n                        if (Constructor.getDefaultProps) {\n                            Constructor.getDefaultProps.isReactClassApproved = {};\n                        }\n                        if (Constructor.prototype.getInitialState) {\n                            Constructor.prototype.getInitialState.isReactClassApproved = {};\n                        }\n                    }\n                    _invariant(Constructor.prototype.render, \"createClass(...): Class specification must implement a `render` method.\");\n                    if (true) {\n                        warning(!Constructor.prototype.componentShouldUpdate, \"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", spec.displayName || \"A component\");\n                        warning(!Constructor.prototype.componentWillRecieveProps, \"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", spec.displayName || \"A component\");\n                        warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, \"%s has a method called UNSAFE_componentWillRecieveProps(). \" + \"Did you mean UNSAFE_componentWillReceiveProps()?\", spec.displayName || \"A component\");\n                    }\n                    // Reduce time spent doing lookups by setting these on the prototype.\n                    for(var methodName in ReactClassInterface){\n                        if (!Constructor.prototype[methodName]) {\n                            Constructor.prototype[methodName] = null;\n                        }\n                    }\n                    return Constructor;\n                }\n                return createClass;\n            }\n            module1.exports = factory;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1) {\n            /*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/ \"use strict\";\n            /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n            function toObject(val) {\n                if (val === null || val === undefined) {\n                    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                }\n                return Object(val);\n            }\n            function shouldUseNative() {\n                try {\n                    if (!Object.assign) {\n                        return false;\n                    }\n                    // Detect buggy property enumeration order in older V8 versions.\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                    var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                    test1[5] = \"de\";\n                    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test2 = {};\n                    for(var i = 0; i < 10; i++){\n                        test2[\"_\" + String.fromCharCode(i)] = i;\n                    }\n                    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                        return test2[n];\n                    });\n                    if (order2.join(\"\") !== \"0123456789\") {\n                        return false;\n                    }\n                    // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                    var test3 = {};\n                    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                        test3[letter] = letter;\n                    });\n                    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                        return false;\n                    }\n                    return true;\n                } catch (err) {\n                    // We don't expect any of the above to throw, but better to be safe.\n                    return false;\n                }\n            }\n            module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                var from;\n                var to = toObject(target);\n                var symbols;\n                for(var s = 1; s < arguments.length; s++){\n                    from = Object(arguments[s]);\n                    for(var key in from){\n                        if (hasOwnProperty.call(from, key)) {\n                            to[key] = from[key];\n                        }\n                    }\n                    if (getOwnPropertySymbols) {\n                        symbols = getOwnPropertySymbols(from);\n                        for(var i = 0; i < symbols.length; i++){\n                            if (propIsEnumerable.call(from, symbols[i])) {\n                                to[symbols[i]] = from[symbols[i]];\n                            }\n                        }\n                    }\n                }\n                return to;\n            };\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1) {\n            /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */ \"use strict\";\n            var emptyObject = {};\n            if (true) {\n                Object.freeze(emptyObject);\n            }\n            module1.exports = emptyObject;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1) {\n            /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */ \"use strict\";\n            /**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_64480__) {\n            /**\n\t * Copyright (c) 2014-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t */ \"use strict\";\n            var emptyFunction = __nested_webpack_require_64480__(8);\n            /**\n\t * Similar to invariant but only logs a warning if the condition is not met.\n\t * This can be used to log issues in development environments in critical\n\t * paths. Removing the logging code for production environments will keep the\n\t * same logic and follow the same code paths.\n\t */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * \n\t */ function makeEmptyFunction(arg) {\n                return function() {\n                    return arg;\n                };\n            }\n            /**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */ var emptyFunction = function emptyFunction() {};\n            emptyFunction.thatReturns = makeEmptyFunction;\n            emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n            emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n            emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n            emptyFunction.thatReturnsThis = function() {\n                return this;\n            };\n            emptyFunction.thatReturnsArgument = function(arg) {\n                return arg;\n            };\n            module1.exports = emptyFunction;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var NumeralFormatter = function NumeralFormatter(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix, signBeforePrefix, tailPrefix, delimiter) {\n                var owner = this;\n                owner.numeralDecimalMark = numeralDecimalMark || \".\";\n                owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;\n                owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;\n                owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;\n                owner.numeralPositiveOnly = !!numeralPositiveOnly;\n                owner.stripLeadingZeroes = stripLeadingZeroes !== false;\n                owner.prefix = prefix || prefix === \"\" ? prefix : \"\";\n                owner.signBeforePrefix = !!signBeforePrefix;\n                owner.tailPrefix = !!tailPrefix;\n                owner.delimiter = delimiter || delimiter === \"\" ? delimiter : \",\";\n                owner.delimiterRE = delimiter ? new RegExp(\"\\\\\" + delimiter, \"g\") : \"\";\n            };\n            NumeralFormatter.groupStyle = {\n                thousand: \"thousand\",\n                lakh: \"lakh\",\n                wan: \"wan\",\n                none: \"none\"\n            };\n            NumeralFormatter.prototype = {\n                getRawValue: function getRawValue(value) {\n                    return value.replace(this.delimiterRE, \"\").replace(this.numeralDecimalMark, \".\");\n                },\n                format: function format(value) {\n                    var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = \"\";\n                    // strip alphabet letters\n                    value = value.replace(/[A-Za-z]/g, \"\")// replace the first decimal mark with reserved placeholder\n                    .replace(owner.numeralDecimalMark, \"M\")// strip non numeric letters except minus and \"M\"\n                    // this is to ensure prefix has been stripped\n                    .replace(/[^\\dM-]/g, \"\")// replace the leading minus with reserved placeholder\n                    .replace(/^\\-/, \"N\")// strip the other minus sign (if present)\n                    .replace(/\\-/g, \"\")// replace the minus sign (if present)\n                    .replace(\"N\", owner.numeralPositiveOnly ? \"\" : \"-\")// replace decimal mark\n                    .replace(\"M\", owner.numeralDecimalMark);\n                    // strip any leading zeros\n                    if (owner.stripLeadingZeroes) {\n                        value = value.replace(/^(-)?0+(?=\\d)/, \"$1\");\n                    }\n                    partSign = value.slice(0, 1) === \"-\" ? \"-\" : \"\";\n                    if (typeof owner.prefix != \"undefined\") {\n                        if (owner.signBeforePrefix) {\n                            partSignAndPrefix = partSign + owner.prefix;\n                        } else {\n                            partSignAndPrefix = owner.prefix + partSign;\n                        }\n                    } else {\n                        partSignAndPrefix = partSign;\n                    }\n                    partInteger = value;\n                    if (value.indexOf(owner.numeralDecimalMark) >= 0) {\n                        parts = value.split(owner.numeralDecimalMark);\n                        partInteger = parts[0];\n                        partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);\n                    }\n                    if (partSign === \"-\") {\n                        partInteger = partInteger.slice(1);\n                    }\n                    if (owner.numeralIntegerScale > 0) {\n                        partInteger = partInteger.slice(0, owner.numeralIntegerScale);\n                    }\n                    switch(owner.numeralThousandsGroupStyle){\n                        case NumeralFormatter.groupStyle.lakh:\n                            partInteger = partInteger.replace(/(\\d)(?=(\\d\\d)+\\d$)/g, \"$1\" + owner.delimiter);\n                            break;\n                        case NumeralFormatter.groupStyle.wan:\n                            partInteger = partInteger.replace(/(\\d)(?=(\\d{4})+$)/g, \"$1\" + owner.delimiter);\n                            break;\n                        case NumeralFormatter.groupStyle.thousand:\n                            partInteger = partInteger.replace(/(\\d)(?=(\\d{3})+$)/g, \"$1\" + owner.delimiter);\n                            break;\n                    }\n                    if (owner.tailPrefix) {\n                        return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : \"\") + owner.prefix;\n                    }\n                    return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : \"\");\n                }\n            };\n            module1.exports = NumeralFormatter;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var DateFormatter = function DateFormatter(datePattern, dateMin, dateMax) {\n                var owner = this;\n                owner.date = [];\n                owner.blocks = [];\n                owner.datePattern = datePattern;\n                owner.dateMin = dateMin.split(\"-\").reverse().map(function(x) {\n                    return parseInt(x, 10);\n                });\n                if (owner.dateMin.length === 2) owner.dateMin.unshift(0);\n                owner.dateMax = dateMax.split(\"-\").reverse().map(function(x) {\n                    return parseInt(x, 10);\n                });\n                if (owner.dateMax.length === 2) owner.dateMax.unshift(0);\n                owner.initBlocks();\n            };\n            DateFormatter.prototype = {\n                initBlocks: function initBlocks() {\n                    var owner = this;\n                    owner.datePattern.forEach(function(value) {\n                        if (value === \"Y\") {\n                            owner.blocks.push(4);\n                        } else {\n                            owner.blocks.push(2);\n                        }\n                    });\n                },\n                getISOFormatDate: function getISOFormatDate() {\n                    var owner = this, date = owner.date;\n                    return date[2] ? date[2] + \"-\" + owner.addLeadingZero(date[1]) + \"-\" + owner.addLeadingZero(date[0]) : \"\";\n                },\n                getBlocks: function getBlocks() {\n                    return this.blocks;\n                },\n                getValidatedDate: function getValidatedDate(value) {\n                    var owner = this, result = \"\";\n                    value = value.replace(/[^\\d]/g, \"\");\n                    owner.blocks.forEach(function(length, index) {\n                        if (value.length > 0) {\n                            var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);\n                            switch(owner.datePattern[index]){\n                                case \"d\":\n                                    if (sub === \"00\") {\n                                        sub = \"01\";\n                                    } else if (parseInt(sub0, 10) > 3) {\n                                        sub = \"0\" + sub0;\n                                    } else if (parseInt(sub, 10) > 31) {\n                                        sub = \"31\";\n                                    }\n                                    break;\n                                case \"m\":\n                                    if (sub === \"00\") {\n                                        sub = \"01\";\n                                    } else if (parseInt(sub0, 10) > 1) {\n                                        sub = \"0\" + sub0;\n                                    } else if (parseInt(sub, 10) > 12) {\n                                        sub = \"12\";\n                                    }\n                                    break;\n                            }\n                            result += sub;\n                            // update remaining string\n                            value = rest;\n                        }\n                    });\n                    return this.getFixedDateString(result);\n                },\n                getFixedDateString: function getFixedDateString(value) {\n                    var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;\n                    // mm-dd || dd-mm\n                    if (value.length === 4 && datePattern[0].toLowerCase() !== \"y\" && datePattern[1].toLowerCase() !== \"y\") {\n                        dayStartIndex = datePattern[0] === \"d\" ? 0 : 2;\n                        monthStartIndex = 2 - dayStartIndex;\n                        day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n                        month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n                        date = this.getFixedDate(day, month, 0);\n                    }\n                    // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd\n                    if (value.length === 8) {\n                        datePattern.forEach(function(type, index) {\n                            switch(type){\n                                case \"d\":\n                                    dayIndex = index;\n                                    break;\n                                case \"m\":\n                                    monthIndex = index;\n                                    break;\n                                default:\n                                    yearIndex = index;\n                                    break;\n                            }\n                        });\n                        yearStartIndex = yearIndex * 2;\n                        dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;\n                        monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;\n                        day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n                        month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n                        year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n                        fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n                        date = this.getFixedDate(day, month, year);\n                    }\n                    // mm-yy || yy-mm\n                    if (value.length === 4 && (datePattern[0] === \"y\" || datePattern[1] === \"y\")) {\n                        monthStartIndex = datePattern[0] === \"m\" ? 0 : 2;\n                        yearStartIndex = 2 - monthStartIndex;\n                        month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n                        year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);\n                        fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;\n                        date = [\n                            0,\n                            month,\n                            year\n                        ];\n                    }\n                    // mm-yyyy || yyyy-mm\n                    if (value.length === 6 && (datePattern[0] === \"Y\" || datePattern[1] === \"Y\")) {\n                        monthStartIndex = datePattern[0] === \"m\" ? 0 : 4;\n                        yearStartIndex = 2 - 0.5 * monthStartIndex;\n                        month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n                        year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n                        fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n                        date = [\n                            0,\n                            month,\n                            year\n                        ];\n                    }\n                    date = owner.getRangeFixedDate(date);\n                    owner.date = date;\n                    var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {\n                        switch(current){\n                            case \"d\":\n                                return previous + (date[0] === 0 ? \"\" : owner.addLeadingZero(date[0]));\n                            case \"m\":\n                                return previous + (date[1] === 0 ? \"\" : owner.addLeadingZero(date[1]));\n                            case \"y\":\n                                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : \"\");\n                            case \"Y\":\n                                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : \"\");\n                        }\n                    }, \"\");\n                    return result;\n                },\n                getRangeFixedDate: function getRangeFixedDate(date) {\n                    var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];\n                    if (!date.length || dateMin.length < 3 && dateMax.length < 3) return date;\n                    if (datePattern.find(function(x) {\n                        return x.toLowerCase() === \"y\";\n                    }) && date[2] === 0) return date;\n                    if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0]))) return dateMax;\n                    if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0]))) return dateMin;\n                    return date;\n                },\n                getFixedDate: function getFixedDate(day, month, year) {\n                    day = Math.min(day, 31);\n                    month = Math.min(month, 12);\n                    year = parseInt(year || 0, 10);\n                    if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {\n                        day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);\n                    }\n                    return [\n                        day,\n                        month,\n                        year\n                    ];\n                },\n                isLeapYear: function isLeapYear(year) {\n                    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n                },\n                addLeadingZero: function addLeadingZero(number) {\n                    return (number < 10 ? \"0\" : \"\") + number;\n                },\n                addLeadingZeroForYear: function addLeadingZeroForYear(number, fullYearMode) {\n                    if (fullYearMode) {\n                        return (number < 10 ? \"000\" : number < 100 ? \"00\" : number < 1000 ? \"0\" : \"\") + number;\n                    }\n                    return (number < 10 ? \"0\" : \"\") + number;\n                }\n            };\n            module1.exports = DateFormatter;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var TimeFormatter = function TimeFormatter(timePattern, timeFormat) {\n                var owner = this;\n                owner.time = [];\n                owner.blocks = [];\n                owner.timePattern = timePattern;\n                owner.timeFormat = timeFormat;\n                owner.initBlocks();\n            };\n            TimeFormatter.prototype = {\n                initBlocks: function initBlocks() {\n                    var owner = this;\n                    owner.timePattern.forEach(function() {\n                        owner.blocks.push(2);\n                    });\n                },\n                getISOFormatTime: function getISOFormatTime() {\n                    var owner = this, time = owner.time;\n                    return time[2] ? owner.addLeadingZero(time[0]) + \":\" + owner.addLeadingZero(time[1]) + \":\" + owner.addLeadingZero(time[2]) : \"\";\n                },\n                getBlocks: function getBlocks() {\n                    return this.blocks;\n                },\n                getTimeFormatOptions: function getTimeFormatOptions() {\n                    var owner = this;\n                    if (String(owner.timeFormat) === \"12\") {\n                        return {\n                            maxHourFirstDigit: 1,\n                            maxHours: 12,\n                            maxMinutesFirstDigit: 5,\n                            maxMinutes: 60\n                        };\n                    }\n                    return {\n                        maxHourFirstDigit: 2,\n                        maxHours: 23,\n                        maxMinutesFirstDigit: 5,\n                        maxMinutes: 60\n                    };\n                },\n                getValidatedTime: function getValidatedTime(value) {\n                    var owner = this, result = \"\";\n                    value = value.replace(/[^\\d]/g, \"\");\n                    var timeFormatOptions = owner.getTimeFormatOptions();\n                    owner.blocks.forEach(function(length, index) {\n                        if (value.length > 0) {\n                            var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);\n                            switch(owner.timePattern[index]){\n                                case \"h\":\n                                    if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {\n                                        sub = \"0\" + sub0;\n                                    } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {\n                                        sub = timeFormatOptions.maxHours + \"\";\n                                    }\n                                    break;\n                                case \"m\":\n                                case \"s\":\n                                    if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {\n                                        sub = \"0\" + sub0;\n                                    } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {\n                                        sub = timeFormatOptions.maxMinutes + \"\";\n                                    }\n                                    break;\n                            }\n                            result += sub;\n                            // update remaining string\n                            value = rest;\n                        }\n                    });\n                    return this.getFixedTimeString(result);\n                },\n                getFixedTimeString: function getFixedTimeString(value) {\n                    var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;\n                    if (value.length === 6) {\n                        timePattern.forEach(function(type, index) {\n                            switch(type){\n                                case \"s\":\n                                    secondIndex = index * 2;\n                                    break;\n                                case \"m\":\n                                    minuteIndex = index * 2;\n                                    break;\n                                case \"h\":\n                                    hourIndex = index * 2;\n                                    break;\n                            }\n                        });\n                        hourStartIndex = hourIndex;\n                        minuteStartIndex = minuteIndex;\n                        secondStartIndex = secondIndex;\n                        second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);\n                        minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n                        hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n                        time = this.getFixedTime(hour, minute, second);\n                    }\n                    if (value.length === 4 && owner.timePattern.indexOf(\"s\") < 0) {\n                        timePattern.forEach(function(type, index) {\n                            switch(type){\n                                case \"m\":\n                                    minuteIndex = index * 2;\n                                    break;\n                                case \"h\":\n                                    hourIndex = index * 2;\n                                    break;\n                            }\n                        });\n                        hourStartIndex = hourIndex;\n                        minuteStartIndex = minuteIndex;\n                        second = 0;\n                        minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n                        hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n                        time = this.getFixedTime(hour, minute, second);\n                    }\n                    owner.time = time;\n                    return time.length === 0 ? value : timePattern.reduce(function(previous, current) {\n                        switch(current){\n                            case \"s\":\n                                return previous + owner.addLeadingZero(time[2]);\n                            case \"m\":\n                                return previous + owner.addLeadingZero(time[1]);\n                            case \"h\":\n                                return previous + owner.addLeadingZero(time[0]);\n                        }\n                    }, \"\");\n                },\n                getFixedTime: function getFixedTime(hour, minute, second) {\n                    second = Math.min(parseInt(second || 0, 10), 60);\n                    minute = Math.min(minute, 60);\n                    hour = Math.min(hour, 60);\n                    return [\n                        hour,\n                        minute,\n                        second\n                    ];\n                },\n                addLeadingZero: function addLeadingZero(number) {\n                    return (number < 10 ? \"0\" : \"\") + number;\n                }\n            };\n            module1.exports = TimeFormatter;\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var PhoneFormatter = function PhoneFormatter(formatter, delimiter) {\n                var owner = this;\n                owner.delimiter = delimiter || delimiter === \"\" ? delimiter : \" \";\n                owner.delimiterRE = delimiter ? new RegExp(\"\\\\\" + delimiter, \"g\") : \"\";\n                owner.formatter = formatter;\n            };\n            PhoneFormatter.prototype = {\n                setFormatter: function setFormatter(formatter) {\n                    this.formatter = formatter;\n                },\n                format: function format(phoneNumber) {\n                    var owner = this;\n                    owner.formatter.clear();\n                    // only keep number and +\n                    phoneNumber = phoneNumber.replace(/[^\\d+]/g, \"\");\n                    // strip non-leading +\n                    phoneNumber = phoneNumber.replace(/^\\+/, \"B\").replace(/\\+/g, \"\").replace(\"B\", \"+\");\n                    // strip delimiter\n                    phoneNumber = phoneNumber.replace(owner.delimiterRE, \"\");\n                    var result = \"\", current, validated = false;\n                    for(var i = 0, iMax = phoneNumber.length; i < iMax; i++){\n                        current = owner.formatter.inputDigit(phoneNumber.charAt(i));\n                        // has ()- or space inside\n                        if (/[\\s()-]/g.test(current)) {\n                            result = current;\n                            validated = true;\n                        } else {\n                            if (!validated) {\n                                result = current;\n                            }\n                        // else: over length input\n                        // it turns to invalid number again\n                        }\n                    }\n                    // strip ()\n                    // e.g. US: 7161234567 returns (716) 123-4567\n                    result = result.replace(/[()]/g, \"\");\n                    // replace library delimiter with user customized delimiter\n                    result = result.replace(/[\\s-]/g, owner.delimiter);\n                    return result;\n                }\n            };\n            module1.exports = PhoneFormatter;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var CreditCardDetector = {\n                blocks: {\n                    uatp: [\n                        4,\n                        5,\n                        6\n                    ],\n                    amex: [\n                        4,\n                        6,\n                        5\n                    ],\n                    diners: [\n                        4,\n                        6,\n                        4\n                    ],\n                    discover: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    mastercard: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    dankort: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    instapayment: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    jcb15: [\n                        4,\n                        6,\n                        5\n                    ],\n                    jcb: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    maestro: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    visa: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    mir: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    unionPay: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ],\n                    general: [\n                        4,\n                        4,\n                        4,\n                        4\n                    ]\n                },\n                re: {\n                    // starts with 1; 15 digits, not starts with 1800 (jcb card)\n                    uatp: /^(?!1800)1\\d{0,14}/,\n                    // starts with 34/37; 15 digits\n                    amex: /^3[47]\\d{0,13}/,\n                    // starts with 6011/65/644-649; 16 digits\n                    discover: /^(?:6011|65\\d{0,2}|64[4-9]\\d?)\\d{0,12}/,\n                    // starts with 300-305/309 or 36/38/39; 14 digits\n                    diners: /^3(?:0([0-5]|9)|[689]\\d?)\\d{0,11}/,\n                    // starts with 51-55/22212720; 16 digits\n                    mastercard: /^(5[1-5]\\d{0,2}|22[2-9]\\d{0,1}|2[3-7]\\d{0,2})\\d{0,12}/,\n                    // starts with 5019/4175/4571; 16 digits\n                    dankort: /^(5019|4175|4571)\\d{0,12}/,\n                    // starts with 637-639; 16 digits\n                    instapayment: /^63[7-9]\\d{0,13}/,\n                    // starts with 2131/1800; 15 digits\n                    jcb15: /^(?:2131|1800)\\d{0,11}/,\n                    // starts with 2131/1800/35; 16 digits\n                    jcb: /^(?:35\\d{0,2})\\d{0,12}/,\n                    // starts with 50/56-58/6304/67; 16 digits\n                    maestro: /^(?:5[0678]\\d{0,2}|6304|67\\d{0,2})\\d{0,12}/,\n                    // starts with 22; 16 digits\n                    mir: /^220[0-4]\\d{0,12}/,\n                    // starts with 4; 16 digits\n                    visa: /^4\\d{0,15}/,\n                    // starts with 62/81; 16 digits\n                    unionPay: /^(62|81)\\d{0,14}/\n                },\n                getStrictBlocks: function getStrictBlocks(block) {\n                    var total = block.reduce(function(prev, current) {\n                        return prev + current;\n                    }, 0);\n                    return block.concat(19 - total);\n                },\n                getInfo: function getInfo(value, strictMode) {\n                    var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;\n                    // Some credit card can have up to 19 digits number.\n                    // Set strictMode to true will remove the 16 max-length restrain,\n                    // however, I never found any website validate card number like\n                    // this, hence probably you don't want to enable this option.\n                    strictMode = !!strictMode;\n                    for(var key in re){\n                        if (re[key].test(value)) {\n                            var matchedBlocks = blocks[key];\n                            return {\n                                type: key,\n                                blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks\n                            };\n                        }\n                    }\n                    return {\n                        type: \"unknown\",\n                        blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general\n                    };\n                }\n            };\n            module1.exports = CreditCardDetector;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var Util = {\n                noop: function noop() {},\n                strip: function strip(value, re) {\n                    return value.replace(re, \"\");\n                },\n                getPostDelimiter: function getPostDelimiter(value, delimiter, delimiters) {\n                    // single delimiter\n                    if (delimiters.length === 0) {\n                        return value.slice(-delimiter.length) === delimiter ? delimiter : \"\";\n                    }\n                    // multiple delimiters\n                    var matchedDelimiter = \"\";\n                    delimiters.forEach(function(current) {\n                        if (value.slice(-current.length) === current) {\n                            matchedDelimiter = current;\n                        }\n                    });\n                    return matchedDelimiter;\n                },\n                getDelimiterREByDelimiter: function getDelimiterREByDelimiter(delimiter) {\n                    return new RegExp(delimiter.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\"), \"g\");\n                },\n                getNextCursorPosition: function getNextCursorPosition(prevPos, oldValue, newValue, delimiter, delimiters) {\n                    // If cursor was at the end of value, just place it back.\n                    // Because new value could contain additional chars.\n                    if (oldValue.length === prevPos) {\n                        return newValue.length;\n                    }\n                    return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);\n                },\n                getPositionOffset: function getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters) {\n                    var oldRawValue, newRawValue, lengthOffset;\n                    oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);\n                    newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);\n                    lengthOffset = oldRawValue.length - newRawValue.length;\n                    return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;\n                },\n                stripDelimiters: function stripDelimiters(value, delimiter, delimiters) {\n                    var owner = this;\n                    // single delimiter\n                    if (delimiters.length === 0) {\n                        var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : \"\";\n                        return value.replace(delimiterRE, \"\");\n                    }\n                    // multiple delimiters\n                    delimiters.forEach(function(current) {\n                        current.split(\"\").forEach(function(letter) {\n                            value = value.replace(owner.getDelimiterREByDelimiter(letter), \"\");\n                        });\n                    });\n                    return value;\n                },\n                headStr: function headStr(str, length) {\n                    return str.slice(0, length);\n                },\n                getMaxLength: function getMaxLength(blocks) {\n                    return blocks.reduce(function(previous, current) {\n                        return previous + current;\n                    }, 0);\n                },\n                // strip prefix\n                // Before type  |   After type    |     Return value\n                // PEFIX-...    |   PEFIX-...     |     ''\n                // PREFIX-123   |   PEFIX-123     |     123\n                // PREFIX-123   |   PREFIX-23     |     23\n                // PREFIX-123   |   PREFIX-1234   |     1234\n                getPrefixStrippedValue: function getPrefixStrippedValue(value, prefix, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {\n                    // No prefix\n                    if (prefixLength === 0) {\n                        return value;\n                    }\n                    // Value is prefix\n                    if (value === prefix && value !== \"\") {\n                        return \"\";\n                    }\n                    if (signBeforePrefix && value.slice(0, 1) == \"-\") {\n                        var prev = prevResult.slice(0, 1) == \"-\" ? prevResult.slice(1) : prevResult;\n                        return \"-\" + this.getPrefixStrippedValue(value.slice(1), prefix, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);\n                    }\n                    // Pre result prefix string does not match pre-defined prefix\n                    if (prevResult.slice(0, prefixLength) !== prefix && !tailPrefix) {\n                        // Check if the first time user entered something\n                        if (noImmediatePrefix && !prevResult && value) return value;\n                        return \"\";\n                    } else if (prevResult.slice(-prefixLength) !== prefix && tailPrefix) {\n                        // Check if the first time user entered something\n                        if (noImmediatePrefix && !prevResult && value) return value;\n                        return \"\";\n                    }\n                    var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);\n                    // New value has issue, someone typed in between prefix letters\n                    // Revert to pre value\n                    if (value.slice(0, prefixLength) !== prefix && !tailPrefix) {\n                        return prevValue.slice(prefixLength);\n                    } else if (value.slice(-prefixLength) !== prefix && tailPrefix) {\n                        return prevValue.slice(0, -prefixLength - 1);\n                    }\n                    // No issue, strip prefix for new value\n                    return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);\n                },\n                getFirstDiffIndex: function getFirstDiffIndex(prev, current) {\n                    var index = 0;\n                    while(prev.charAt(index) === current.charAt(index)){\n                        if (prev.charAt(index++) === \"\") {\n                            return -1;\n                        }\n                    }\n                    return index;\n                },\n                getFormattedValue: function getFormattedValue(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {\n                    var result = \"\", multipleDelimiters = delimiters.length > 0, currentDelimiter = \"\";\n                    // no options, normal input\n                    if (blocksLength === 0) {\n                        return value;\n                    }\n                    blocks.forEach(function(length, index) {\n                        if (value.length > 0) {\n                            var sub = value.slice(0, length), rest = value.slice(length);\n                            if (multipleDelimiters) {\n                                currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;\n                            } else {\n                                currentDelimiter = delimiter;\n                            }\n                            if (delimiterLazyShow) {\n                                if (index > 0) {\n                                    result += currentDelimiter;\n                                }\n                                result += sub;\n                            } else {\n                                result += sub;\n                                if (sub.length === length && index < blocksLength - 1) {\n                                    result += currentDelimiter;\n                                }\n                            }\n                            // update remaining string\n                            value = rest;\n                        }\n                    });\n                    return result;\n                },\n                // move cursor to the end\n                // the first time user focuses on an input with prefix\n                fixPrefixCursor: function fixPrefixCursor(el, prefix, delimiter, delimiters) {\n                    if (!el) {\n                        return;\n                    }\n                    var val = el.value, appendix = delimiter || delimiters[0] || \" \";\n                    if (!el.setSelectionRange || !prefix || prefix.length + appendix.length <= val.length) {\n                        return;\n                    }\n                    var len = val.length * 2;\n                    // set timeout to avoid blink\n                    setTimeout(function() {\n                        el.setSelectionRange(len, len);\n                    }, 1);\n                },\n                // Check if input field is fully selected\n                checkFullSelection: function checkFullSelection(value) {\n                    try {\n                        var selection = window.getSelection() || document.getSelection() || {};\n                        return selection.toString().length === value.length;\n                    } catch (ex) {\n                    // Ignore\n                    }\n                    return false;\n                },\n                setSelection: function setSelection(element, position, doc) {\n                    if (element !== this.getActiveElement(doc)) {\n                        return;\n                    }\n                    // cursor is already in the end\n                    if (element && element.value.length <= position) {\n                        return;\n                    }\n                    if (element.createTextRange) {\n                        var range = element.createTextRange();\n                        range.move(\"character\", position);\n                        range.select();\n                    } else {\n                        try {\n                            element.setSelectionRange(position, position);\n                        } catch (e) {\n                            // eslint-disable-next-line\n                            console.warn(\"The input element type does not support selection\");\n                        }\n                    }\n                },\n                getActiveElement: function getActiveElement(parent) {\n                    var activeElement = parent.activeElement;\n                    if (activeElement && activeElement.shadowRoot) {\n                        return this.getActiveElement(activeElement.shadowRoot);\n                    }\n                    return activeElement;\n                },\n                isAndroid: function isAndroid() {\n                    return navigator && /android/i.test(navigator.userAgent);\n                },\n                // On Android chrome, the keyup and keydown events\n                // always return key code 229 as a composition that\n                // buffers the users keystrokes\n                // see https://github.com/nosir/cleave.js/issues/147\n                isAndroidBackspaceKeydown: function isAndroidBackspaceKeydown(lastInputValue, currentInputValue) {\n                    if (!this.isAndroid() || !lastInputValue || !currentInputValue) {\n                        return false;\n                    }\n                    return currentInputValue === lastInputValue.slice(0, -1);\n                }\n            };\n            module1.exports = Util;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            /**\n\t * Props Assignment\n\t *\n\t * Separate this, so react module can share the usage\n\t */ var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var DefaultProperties = {\n                // Maybe change to object-assign\n                // for now just keep it as simple\n                assign: function assign(target, opts) {\n                    target = target || {};\n                    opts = opts || {};\n                    // credit card\n                    target.creditCard = !!opts.creditCard;\n                    target.creditCardStrictMode = !!opts.creditCardStrictMode;\n                    target.creditCardType = \"\";\n                    target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {};\n                    // phone\n                    target.phone = !!opts.phone;\n                    target.phoneRegionCode = opts.phoneRegionCode || \"AU\";\n                    target.phoneFormatter = {};\n                    // time\n                    target.time = !!opts.time;\n                    target.timePattern = opts.timePattern || [\n                        \"h\",\n                        \"m\",\n                        \"s\"\n                    ];\n                    target.timeFormat = opts.timeFormat || \"24\";\n                    target.timeFormatter = {};\n                    // date\n                    target.date = !!opts.date;\n                    target.datePattern = opts.datePattern || [\n                        \"d\",\n                        \"m\",\n                        \"Y\"\n                    ];\n                    target.dateMin = opts.dateMin || \"\";\n                    target.dateMax = opts.dateMax || \"\";\n                    target.dateFormatter = {};\n                    // numeral\n                    target.numeral = !!opts.numeral;\n                    target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;\n                    target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;\n                    target.numeralDecimalMark = opts.numeralDecimalMark || \".\";\n                    target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || \"thousand\";\n                    target.numeralPositiveOnly = !!opts.numeralPositiveOnly;\n                    target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;\n                    target.signBeforePrefix = !!opts.signBeforePrefix;\n                    target.tailPrefix = !!opts.tailPrefix;\n                    // others\n                    target.swapHiddenInput = !!opts.swapHiddenInput;\n                    target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;\n                    target.uppercase = !!opts.uppercase;\n                    target.lowercase = !!opts.lowercase;\n                    target.prefix = target.creditCard || target.date ? \"\" : opts.prefix || \"\";\n                    target.noImmediatePrefix = !!opts.noImmediatePrefix;\n                    target.prefixLength = target.prefix.length;\n                    target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;\n                    target.copyDelimiter = !!opts.copyDelimiter;\n                    target.initValue = opts.initValue !== undefined && opts.initValue !== null ? opts.initValue.toString() : \"\";\n                    target.delimiter = opts.delimiter || opts.delimiter === \"\" ? opts.delimiter : opts.date ? \"/\" : opts.time ? \":\" : opts.numeral ? \",\" : opts.phone ? \" \" : \" \";\n                    target.delimiterLength = target.delimiter.length;\n                    target.delimiterLazyShow = !!opts.delimiterLazyShow;\n                    target.delimiters = opts.delimiters || [];\n                    target.blocks = opts.blocks || [];\n                    target.blocksLength = target.blocks.length;\n                    target.root = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) === \"object\" && global ? global : window;\n                    target.document = opts.document || target.root.document;\n                    target.maxLength = 0;\n                    target.backspace = false;\n                    target.result = \"\";\n                    target.onValueChanged = opts.onValueChanged || function() {};\n                    return target;\n                }\n            };\n            module1.exports = DefaultProperties;\n        /***/ }\n    ]);\n});\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2NsZWF2ZS5qcy9kaXN0L2NsZWF2ZS1yZWFjdC1ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsd0dBQU87U0FDcEMsRUFLb0M7QUFDMUMsR0FBRyxJQUFJLEVBQUUsU0FBU0csNkJBQTZCO0lBQy9DLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBRWxDLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUUvQyxNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUN4QyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1QsT0FBTztZQUVyRCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTTSxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1ULFNBQVMsQ0FBQztnQkFDdEIsTUFBTSxHQUFNVSxJQUFJRDtnQkFDaEIsTUFBTSxHQUFNRSxRQUFRO1lBQ1Q7WUFFWCxNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS0wsT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ1gsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVRLDhCQUFtQkE7WUFFN0YsTUFBTSxHQUFLLDRCQUE0QjtZQUN2QyxNQUFNLEdBQUtQLFFBQU9VLE1BQU0sR0FBRztZQUUzQixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFPVixRQUFPRCxPQUFPO1FBQ2hDLE1B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QztRQUVsQixHQUFHLEdBQUc7S0FDSTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9jbGVhdmUuanMvZGlzdC9jbGVhdmUtcmVhY3Qtbm9kZS5qcz9kZjY5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsZWF2ZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDbGVhdmVcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cblx0ZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cdHZhciBSZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0dmFyIENyZWF0ZVJlYWN0Q2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBOdW1lcmFsRm9ybWF0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIERhdGVGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIFRpbWVGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIFBob25lRm9ybWF0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBDcmVkaXRDYXJkRGV0ZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0dmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIERlZmF1bHRQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cblx0dmFyIGNsZWF2ZVJlYWN0Q2xhc3MgPSBDcmVhdGVSZWFjdENsYXNzKHtcblx0ICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcblx0ICAgICAgICB0aGlzLmluaXQoKTtcblx0ICAgIH0sXG5cblx0ICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBob25lUmVnaW9uQ29kZSA9IChvd25lci5wcm9wcy5vcHRpb25zIHx8IHt9KS5waG9uZVJlZ2lvbkNvZGUsXG5cdCAgICAgICAgICAgIG5ld1ZhbHVlID0gb3duZXIucHJvcHMudmFsdWUsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBvd25lci51cGRhdGVSZWdpc3RlcmVkRXZlbnRzKG93bmVyLnByb3BzKTtcblx0ICAgICAgICBpZiAocHJldlByb3BzLnZhbHVlICE9PSBuZXdWYWx1ZSAmJiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcblxuXHQgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IG93bmVyLnByb3BlcnRpZXMucmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBvd25lci5wcm9wZXJ0aWVzLmluaXRWYWx1ZSA9IG5ld1ZhbHVlO1xuXHQgICAgICAgICAgICAgICAgb3duZXIub25JbnB1dChuZXdWYWx1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB1cGRhdGUgcGhvbmUgcmVnaW9uIGNvZGVcblx0ICAgICAgICB2YXIgcHJldlBob25lUmVnaW9uQ29kZSA9IChwcmV2UHJvcHMub3B0aW9ucyB8fCB7fSkucGhvbmVSZWdpb25Db2RlO1xuXHQgICAgICAgIGlmIChwcmV2UGhvbmVSZWdpb25Db2RlICE9PSBwaG9uZVJlZ2lvbkNvZGUgJiYgcGhvbmVSZWdpb25Db2RlICYmIHBob25lUmVnaW9uQ29kZSAhPT0gb3duZXIucHJvcGVydGllcy5waG9uZVJlZ2lvbkNvZGUpIHtcblx0ICAgICAgICAgICAgb3duZXIucHJvcGVydGllcy5waG9uZVJlZ2lvbkNvZGUgPSBwaG9uZVJlZ2lvbkNvZGU7XG5cdCAgICAgICAgICAgIG93bmVyLmluaXRQaG9uZUZvcm1hdHRlcigpO1xuXHQgICAgICAgICAgICBvd25lci5vbklucHV0KG93bmVyLnByb3BlcnRpZXMucmVzdWx0KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBVdGlsLnNldFNlbGVjdGlvbihvd25lci5lbGVtZW50LCBvd25lci5zdGF0ZS5jdXJzb3JQb3NpdGlvbiwgcHBzLmRvY3VtZW50KTtcblx0ICAgIH0sXG5cblx0ICAgIHVwZGF0ZVJlZ2lzdGVyZWRFdmVudHM6IGZ1bmN0aW9uIHVwZGF0ZVJlZ2lzdGVyZWRFdmVudHMocHJvcHMpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4gPSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLFxuXHQgICAgICAgICAgICBvbktleURvd24gPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25LZXlEb3duLFxuXHQgICAgICAgICAgICBvbkNoYW5nZSA9IF9vd25lciRyZWdpc3RlcmVkRXZlbi5vbkNoYW5nZSxcblx0ICAgICAgICAgICAgb25Gb2N1cyA9IF9vd25lciRyZWdpc3RlcmVkRXZlbi5vbkZvY3VzLFxuXHQgICAgICAgICAgICBvbkJsdXIgPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25CbHVyLFxuXHQgICAgICAgICAgICBvbkluaXQgPSBfb3duZXIkcmVnaXN0ZXJlZEV2ZW4ub25Jbml0O1xuXG5cblx0ICAgICAgICBpZiAocHJvcHMub25Jbml0ICYmIHByb3BzLm9uSW5pdCAhPT0gb25Jbml0KSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uSW5pdCA9IHByb3BzLm9uSW5pdDtcblx0ICAgICAgICBpZiAocHJvcHMub25DaGFuZ2UgJiYgcHJvcHMub25DaGFuZ2UgIT09IG9uQ2hhbmdlKSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2U7XG5cdCAgICAgICAgaWYgKHByb3BzLm9uRm9jdXMgJiYgcHJvcHMub25Gb2N1cyAhPT0gb25Gb2N1cykgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkZvY3VzID0gcHJvcHMub25Gb2N1cztcblx0ICAgICAgICBpZiAocHJvcHMub25CbHVyICYmIHByb3BzLm9uQmx1ciAhPT0gb25CbHVyKSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uQmx1ciA9IHByb3BzLm9uQmx1cjtcblx0ICAgICAgICBpZiAocHJvcHMub25LZXlEb3duICYmIHByb3BzLm9uS2V5RG93biAhPT0gb25LZXlEb3duKSBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bjtcblx0ICAgIH0sXG5cblx0ICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIF9vd25lciRwcm9wcyA9IG93bmVyLnByb3BzLFxuXHQgICAgICAgICAgICB2YWx1ZSA9IF9vd25lciRwcm9wcy52YWx1ZSxcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IF9vd25lciRwcm9wcy5vcHRpb25zLFxuXHQgICAgICAgICAgICBvbktleURvd24gPSBfb3duZXIkcHJvcHMub25LZXlEb3duLFxuXHQgICAgICAgICAgICBvbkNoYW5nZSA9IF9vd25lciRwcm9wcy5vbkNoYW5nZSxcblx0ICAgICAgICAgICAgb25Gb2N1cyA9IF9vd25lciRwcm9wcy5vbkZvY3VzLFxuXHQgICAgICAgICAgICBvbkJsdXIgPSBfb3duZXIkcHJvcHMub25CbHVyLFxuXHQgICAgICAgICAgICBvbkluaXQgPSBfb3duZXIkcHJvcHMub25Jbml0O1xuXG5cblx0ICAgICAgICBvd25lci5yZWdpc3RlcmVkRXZlbnRzID0ge1xuXHQgICAgICAgICAgICBvbkluaXQ6IG9uSW5pdCB8fCBVdGlsLm5vb3AsXG5cdCAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSB8fCBVdGlsLm5vb3AsXG5cdCAgICAgICAgICAgIG9uRm9jdXM6IG9uRm9jdXMgfHwgVXRpbC5ub29wLFxuXHQgICAgICAgICAgICBvbkJsdXI6IG9uQmx1ciB8fCBVdGlsLm5vb3AsXG5cdCAgICAgICAgICAgIG9uS2V5RG93bjogb25LZXlEb3duIHx8IFV0aWwubm9vcFxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG9wdGlvbnMuaW5pdFZhbHVlID0gdmFsdWU7XG5cblx0ICAgICAgICBvd25lci5wcm9wZXJ0aWVzID0gRGVmYXVsdFByb3BlcnRpZXMuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBvd25lci5wcm9wZXJ0aWVzLnJlc3VsdCxcblx0ICAgICAgICAgICAgY3Vyc29yUG9zaXRpb246IDBcblx0ICAgICAgICB9O1xuXHQgICAgfSxcblxuXHQgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgLy8gc28gbm8gbmVlZCBmb3IgdGhpcyBsaWIgYXQgYWxsXG5cdCAgICAgICAgaWYgKCFwcHMubnVtZXJhbCAmJiAhcHBzLnBob25lICYmICFwcHMuY3JlZGl0Q2FyZCAmJiAhcHBzLnRpbWUgJiYgIXBwcy5kYXRlICYmIHBwcy5ibG9ja3NMZW5ndGggPT09IDAgJiYgIXBwcy5wcmVmaXgpIHtcblx0ICAgICAgICAgICAgb3duZXIub25JbnB1dChwcHMuaW5pdFZhbHVlKTtcblx0ICAgICAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkluaXQob3duZXIpO1xuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMubWF4TGVuZ3RoID0gVXRpbC5nZXRNYXhMZW5ndGgocHBzLmJsb2Nrcyk7XG5cblx0ICAgICAgICBvd25lci5pc0FuZHJvaWQgPSBVdGlsLmlzQW5kcm9pZCgpO1xuXG5cdCAgICAgICAgb3duZXIuaW5pdFBob25lRm9ybWF0dGVyKCk7XG5cdCAgICAgICAgb3duZXIuaW5pdERhdGVGb3JtYXR0ZXIoKTtcblx0ICAgICAgICBvd25lci5pbml0VGltZUZvcm1hdHRlcigpO1xuXHQgICAgICAgIG93bmVyLmluaXROdW1lcmFsRm9ybWF0dGVyKCk7XG5cblx0ICAgICAgICAvLyBhdm9pZCB0b3VjaCBpbnB1dCBmaWVsZCBpZiB2YWx1ZSBpcyBudWxsXG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIEZpcmVmb3ggd2lsbCBhZGQgcmVkIGJveC1zaGFkb3cgZm9yIDxpbnB1dCByZXF1aXJlZCAvPlxuXHQgICAgICAgIGlmIChwcHMuaW5pdFZhbHVlIHx8IHBwcy5wcmVmaXggJiYgIXBwcy5ub0ltbWVkaWF0ZVByZWZpeCkge1xuXHQgICAgICAgICAgICBvd25lci5vbklucHV0KHBwcy5pbml0VmFsdWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25Jbml0KG93bmVyKTtcblx0ICAgIH0sXG5cblx0ICAgIGluaXROdW1lcmFsRm9ybWF0dGVyOiBmdW5jdGlvbiBpbml0TnVtZXJhbEZvcm1hdHRlcigpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgaWYgKCFwcHMubnVtZXJhbCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHBzLm51bWVyYWxGb3JtYXR0ZXIgPSBuZXcgTnVtZXJhbEZvcm1hdHRlcihwcHMubnVtZXJhbERlY2ltYWxNYXJrLCBwcHMubnVtZXJhbEludGVnZXJTY2FsZSwgcHBzLm51bWVyYWxEZWNpbWFsU2NhbGUsIHBwcy5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSwgcHBzLm51bWVyYWxQb3NpdGl2ZU9ubHksIHBwcy5zdHJpcExlYWRpbmdaZXJvZXMsIHBwcy5wcmVmaXgsIHBwcy5zaWduQmVmb3JlUHJlZml4LCBwcHMudGFpbFByZWZpeCwgcHBzLmRlbGltaXRlcik7XG5cdCAgICB9LFxuXG5cdCAgICBpbml0VGltZUZvcm1hdHRlcjogZnVuY3Rpb24gaW5pdFRpbWVGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIGlmICghcHBzLnRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBwcy50aW1lRm9ybWF0dGVyID0gbmV3IFRpbWVGb3JtYXR0ZXIocHBzLnRpbWVQYXR0ZXJuLCBwcHMudGltZUZvcm1hdCk7XG5cdCAgICAgICAgcHBzLmJsb2NrcyA9IHBwcy50aW1lRm9ybWF0dGVyLmdldEJsb2NrcygpO1xuXHQgICAgICAgIHBwcy5ibG9ja3NMZW5ndGggPSBwcHMuYmxvY2tzLmxlbmd0aDtcblx0ICAgICAgICBwcHMubWF4TGVuZ3RoID0gVXRpbC5nZXRNYXhMZW5ndGgocHBzLmJsb2Nrcyk7XG5cdCAgICB9LFxuXG5cdCAgICBpbml0RGF0ZUZvcm1hdHRlcjogZnVuY3Rpb24gaW5pdERhdGVGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIGlmICghcHBzLmRhdGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBwcy5kYXRlRm9ybWF0dGVyID0gbmV3IERhdGVGb3JtYXR0ZXIocHBzLmRhdGVQYXR0ZXJuLCBwcHMuZGF0ZU1pbiwgcHBzLmRhdGVNYXgpO1xuXHQgICAgICAgIHBwcy5ibG9ja3MgPSBwcHMuZGF0ZUZvcm1hdHRlci5nZXRCbG9ja3MoKTtcblx0ICAgICAgICBwcHMuYmxvY2tzTGVuZ3RoID0gcHBzLmJsb2Nrcy5sZW5ndGg7XG5cdCAgICAgICAgcHBzLm1heExlbmd0aCA9IFV0aWwuZ2V0TWF4TGVuZ3RoKHBwcy5ibG9ja3MpO1xuXHQgICAgfSxcblxuXHQgICAgaW5pdFBob25lRm9ybWF0dGVyOiBmdW5jdGlvbiBpbml0UGhvbmVGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIGlmICghcHBzLnBob25lKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDbGVhdmUuQXNZb3VUeXBlRm9ybWF0dGVyIHNob3VsZCBiZSBwcm92aWRlZCBieVxuXHQgICAgICAgIC8vIGV4dGVybmFsIGdvb2dsZSBjbG9zdXJlIGxpYlxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHBwcy5waG9uZUZvcm1hdHRlciA9IG5ldyBQaG9uZUZvcm1hdHRlcihuZXcgcHBzLnJvb3QuQ2xlYXZlLkFzWW91VHlwZUZvcm1hdHRlcihwcHMucGhvbmVSZWdpb25Db2RlKSwgcHBzLmRlbGltaXRlcik7XG5cdCAgICAgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW5jbHVkZSBwaG9uZS10eXBlLWZvcm1hdHRlci57Y291bnRyeX0uanMgbGliJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgc2V0UmF3VmFsdWU6IGZ1bmN0aW9uIHNldFJhd1ZhbHVlKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcblxuXHQgICAgICAgIGlmIChwcHMubnVtZXJhbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCBwcHMubnVtZXJhbERlY2ltYWxNYXJrKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgb3duZXIub25DaGFuZ2Uoe1xuXHQgICAgICAgICAgICB0YXJnZXQ6IHsgdmFsdWU6IHZhbHVlIH0sXG5cblx0ICAgICAgICAgICAgLy8gTWV0aG9kcyB0byBiZXR0ZXIgcmVzZW1ibGUgYSBTeW50aGV0aWNFdmVudFxuXHQgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IFV0aWwubm9vcCxcblx0ICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IFV0aWwubm9vcCxcblx0ICAgICAgICAgICAgcGVyc2lzdDogVXRpbC5ub29wXG5cdCAgICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gZ2V0UmF3VmFsdWUoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcHBzID0gb3duZXIucHJvcGVydGllcyxcblx0ICAgICAgICAgICAgcmF3VmFsdWUgPSBwcHMucmVzdWx0O1xuXG5cdCAgICAgICAgaWYgKHBwcy5yYXdWYWx1ZVRyaW1QcmVmaXgpIHtcblx0ICAgICAgICAgICAgcmF3VmFsdWUgPSBVdGlsLmdldFByZWZpeFN0cmlwcGVkVmFsdWUocmF3VmFsdWUsIHBwcy5wcmVmaXgsIHBwcy5wcmVmaXhMZW5ndGgsIHBwcy5yZXN1bHQsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzLCBwcHMubm9JbW1lZGlhdGVQcmVmaXgsIHBwcy50YWlsUHJlZml4LCBwcHMuc2lnbkJlZm9yZVByZWZpeCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBwcy5udW1lcmFsKSB7XG5cdCAgICAgICAgICAgIHJhd1ZhbHVlID0gcHBzLm51bWVyYWxGb3JtYXR0ZXIgPyBwcHMubnVtZXJhbEZvcm1hdHRlci5nZXRSYXdWYWx1ZShyYXdWYWx1ZSkgOiAnJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByYXdWYWx1ZSA9IFV0aWwuc3RyaXBEZWxpbWl0ZXJzKHJhd1ZhbHVlLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0SVNPRm9ybWF0RGF0ZTogZnVuY3Rpb24gZ2V0SVNPRm9ybWF0RGF0ZSgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgcmV0dXJuIHBwcy5kYXRlID8gcHBzLmRhdGVGb3JtYXR0ZXIuZ2V0SVNPRm9ybWF0RGF0ZSgpIDogJyc7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRJU09Gb3JtYXRUaW1lOiBmdW5jdGlvbiBnZXRJU09Gb3JtYXRUaW1lKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICByZXR1cm4gcHBzLnRpbWUgPyBwcHMudGltZUZvcm1hdHRlci5nZXRJU09Gb3JtYXRUaW1lKCkgOiAnJztcblx0ICAgIH0sXG5cblx0ICAgIG9uSW5pdDogZnVuY3Rpb24gb25Jbml0KG93bmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIG93bmVyO1xuXHQgICAgfSxcblxuXHQgICAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzLFxuXHQgICAgICAgICAgICBjaGFyQ29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cblx0ICAgICAgICBvd25lci5sYXN0SW5wdXRWYWx1ZSA9IHBwcy5yZXN1bHQ7XG5cdCAgICAgICAgb3duZXIuaXNCYWNrd2FyZCA9IGNoYXJDb2RlID09PSA4O1xuXG5cdCAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbktleURvd24oZXZlbnQpO1xuXHQgICAgfSxcblxuXHQgICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAocHBzLnByZWZpeCAmJiBwcHMubm9JbW1lZGlhdGVQcmVmaXggJiYgIWV2ZW50LnRhcmdldC52YWx1ZSkge1xuXHQgICAgICAgICAgICBvd25lci5vbklucHV0KHBwcy5wcmVmaXgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGV2ZW50LnRhcmdldC5yYXdWYWx1ZSA9IG93bmVyLmdldFJhd1ZhbHVlKCk7XG5cdCAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gcHBzLnJlc3VsdDtcblxuXHQgICAgICAgIG93bmVyLnJlZ2lzdGVyZWRFdmVudHMub25Gb2N1cyhldmVudCk7XG5cblx0ICAgICAgICBVdGlsLmZpeFByZWZpeEN1cnNvcihvd25lci5lbGVtZW50LCBwcHMucHJlZml4LCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cdCAgICB9LFxuXG5cdCAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihldmVudCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBldmVudC50YXJnZXQucmF3VmFsdWUgPSBvd25lci5nZXRSYXdWYWx1ZSgpO1xuXHQgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IHBwcy5yZXN1bHQ7XG5cblx0ICAgICAgICBvd25lci5yZWdpc3RlcmVkRXZlbnRzLm9uQmx1cihldmVudCk7XG5cdCAgICB9LFxuXG5cdCAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgb3duZXIuaXNCYWNrd2FyZCA9IG93bmVyLmlzQmFja3dhcmQgfHwgZXZlbnQuaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJztcblx0ICAgICAgICAvLyBoaXQgYmFja3NwYWNlIHdoZW4gbGFzdCBjaGFyYWN0ZXIgaXMgZGVsaW1pdGVyXG5cdCAgICAgICAgdmFyIHBvc3REZWxpbWl0ZXIgPSBVdGlsLmdldFBvc3REZWxpbWl0ZXIob3duZXIubGFzdElucHV0VmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblxuXHQgICAgICAgIGlmIChvd25lci5pc0JhY2t3YXJkICYmIHBvc3REZWxpbWl0ZXIpIHtcblx0ICAgICAgICAgICAgcHBzLnBvc3REZWxpbWl0ZXJCYWNrc3BhY2UgPSBwb3N0RGVsaW1pdGVyO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb3duZXIub25JbnB1dChldmVudC50YXJnZXQudmFsdWUpO1xuXG5cdCAgICAgICAgZXZlbnQudGFyZ2V0LnJhd1ZhbHVlID0gb3duZXIuZ2V0UmF3VmFsdWUoKTtcblx0ICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBwcHMucmVzdWx0O1xuXG5cdCAgICAgICAgb3duZXIucmVnaXN0ZXJlZEV2ZW50cy5vbkNoYW5nZShldmVudCk7XG5cdCAgICB9LFxuXG5cdCAgICBvbklucHV0OiBmdW5jdGlvbiBvbklucHV0KHZhbHVlLCBmcm9tUHJvcHMpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgLy8gY2FzZSAxOiBkZWxldGUgb25lIG1vcmUgY2hhcmFjdGVyIFwiNFwiXG5cdCAgICAgICAgLy8gMTIzNCp8IC0+IGhpdCBiYWNrc3BhY2UgLT4gMTIzfFxuXHQgICAgICAgIC8vIGNhc2UgMjogbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGRlbGltaXRlciB3aGljaCBpczpcblx0ICAgICAgICAvLyAxMnwzNCogLT4gaGl0IGJhY2tzcGFjZSAtPiAxfDM0KlxuXHQgICAgICAgIHZhciBwb3N0RGVsaW1pdGVyQWZ0ZXIgPSBVdGlsLmdldFBvc3REZWxpbWl0ZXIodmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblx0ICAgICAgICBpZiAoIWZyb21Qcm9wcyAmJiAhcHBzLm51bWVyYWwgJiYgcHBzLnBvc3REZWxpbWl0ZXJCYWNrc3BhY2UgJiYgIXBvc3REZWxpbWl0ZXJBZnRlcikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IFV0aWwuaGVhZFN0cih2YWx1ZSwgdmFsdWUubGVuZ3RoIC0gcHBzLnBvc3REZWxpbWl0ZXJCYWNrc3BhY2UubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBwaG9uZSBmb3JtYXR0ZXJcblx0ICAgICAgICBpZiAocHBzLnBob25lKSB7XG5cdCAgICAgICAgICAgIGlmIChwcHMucHJlZml4ICYmICghcHBzLm5vSW1tZWRpYXRlUHJlZml4IHx8IHZhbHVlLmxlbmd0aCkpIHtcblx0ICAgICAgICAgICAgICAgIHBwcy5yZXN1bHQgPSBwcHMucHJlZml4ICsgcHBzLnBob25lRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkuc2xpY2UocHBzLnByZWZpeC5sZW5ndGgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9IHBwcy5waG9uZUZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG93bmVyLnVwZGF0ZVZhbHVlU3RhdGUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gbnVtZXJhbCBmb3JtYXR0ZXJcblx0ICAgICAgICBpZiAocHBzLm51bWVyYWwpIHtcblx0ICAgICAgICAgICAgLy8gRG8gbm90IHNob3cgcHJlZml4IHdoZW4gbm9JbW1lZGlhdGVQcmVmaXggaXMgc3BlY2lmaWVkXG5cdCAgICAgICAgICAgIC8vIFRoaXMgbW9zdGx5IGJlY2F1c2Ugd2UgbmVlZCB0byBzaG93IHVzZXIgdGhlIG5hdGl2ZSBpbnB1dCBwbGFjZWhvbGRlclxuXHQgICAgICAgICAgICBpZiAocHBzLnByZWZpeCAmJiBwcHMubm9JbW1lZGlhdGVQcmVmaXggJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gJyc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gcHBzLm51bWVyYWxGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGRhdGVcblx0ICAgICAgICBpZiAocHBzLmRhdGUpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBwcHMuZGF0ZUZvcm1hdHRlci5nZXRWYWxpZGF0ZWREYXRlKHZhbHVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aW1lXG5cdCAgICAgICAgaWYgKHBwcy50aW1lKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gcHBzLnRpbWVGb3JtYXR0ZXIuZ2V0VmFsaWRhdGVkVGltZSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gc3RyaXAgZGVsaW1pdGVyc1xuXHQgICAgICAgIHZhbHVlID0gVXRpbC5zdHJpcERlbGltaXRlcnModmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblxuXHQgICAgICAgIC8vIHN0cmlwIHByZWZpeFxuXHQgICAgICAgIHZhbHVlID0gVXRpbC5nZXRQcmVmaXhTdHJpcHBlZFZhbHVlKHZhbHVlLCBwcHMucHJlZml4LCBwcHMucHJlZml4TGVuZ3RoLCBwcHMucmVzdWx0LCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycywgcHBzLm5vSW1tZWRpYXRlUHJlZml4LCBwcHMudGFpbFByZWZpeCwgcHBzLnNpZ25CZWZvcmVQcmVmaXgpO1xuXG5cdCAgICAgICAgLy8gc3RyaXAgbm9uLW51bWVyaWMgY2hhcmFjdGVyc1xuXHQgICAgICAgIHZhbHVlID0gcHBzLm51bWVyaWNPbmx5ID8gVXRpbC5zdHJpcCh2YWx1ZSwgL1teXFxkXS9nKSA6IHZhbHVlO1xuXG5cdCAgICAgICAgLy8gY29udmVydCBjYXNlXG5cdCAgICAgICAgdmFsdWUgPSBwcHMudXBwZXJjYXNlID8gdmFsdWUudG9VcHBlckNhc2UoKSA6IHZhbHVlO1xuXHQgICAgICAgIHZhbHVlID0gcHBzLmxvd2VyY2FzZSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZTtcblxuXHQgICAgICAgIC8vIHByZXZlbnQgZnJvbSBzaG93aW5nIHByZWZpeCB3aGVuIG5vIGltbWVkaWF0ZSBvcHRpb24gZW5hYmxlZCB3aXRoIGVtcHR5IGlucHV0IHZhbHVlXG5cdCAgICAgICAgaWYgKHBwcy5wcmVmaXgpIHtcblx0ICAgICAgICAgICAgaWYgKHBwcy50YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgcHBzLnByZWZpeDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcHBzLnByZWZpeCArIHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gbm8gYmxvY2tzIHNwZWNpZmllZCwgbm8gbmVlZCB0byBkbyBmb3JtYXR0aW5nXG5cdCAgICAgICAgICAgIGlmIChwcHMuYmxvY2tzTGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHVwZGF0ZSBjcmVkaXQgY2FyZCBwcm9wc1xuXHQgICAgICAgIGlmIChwcHMuY3JlZGl0Q2FyZCkge1xuXHQgICAgICAgICAgICBvd25lci51cGRhdGVDcmVkaXRDYXJkUHJvcHNCeVZhbHVlKHZhbHVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBzdHJpcCBvdmVyIGxlbmd0aCBjaGFyYWN0ZXJzXG5cdCAgICAgICAgdmFsdWUgPSBwcHMubWF4TGVuZ3RoID4gMCA/IFV0aWwuaGVhZFN0cih2YWx1ZSwgcHBzLm1heExlbmd0aCkgOiB2YWx1ZTtcblxuXHQgICAgICAgIC8vIGFwcGx5IGJsb2Nrc1xuXHQgICAgICAgIHBwcy5yZXN1bHQgPSBVdGlsLmdldEZvcm1hdHRlZFZhbHVlKHZhbHVlLCBwcHMuYmxvY2tzLCBwcHMuYmxvY2tzTGVuZ3RoLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycywgcHBzLmRlbGltaXRlckxhenlTaG93KTtcblxuXHQgICAgICAgIG93bmVyLnVwZGF0ZVZhbHVlU3RhdGUoKTtcblx0ICAgIH0sXG5cblx0ICAgIHVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWUodmFsdWUpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzLFxuXHQgICAgICAgICAgICBjcmVkaXRDYXJkSW5mbztcblxuXHQgICAgICAgIC8vIEF0IGxlYXN0IG9uZSBvZiB0aGUgZmlyc3QgNCBjaGFyYWN0ZXJzIGhhcyBjaGFuZ2VkXG5cdCAgICAgICAgaWYgKFV0aWwuaGVhZFN0cihwcHMucmVzdWx0LCA0KSA9PT0gVXRpbC5oZWFkU3RyKHZhbHVlLCA0KSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3JlZGl0Q2FyZEluZm8gPSBDcmVkaXRDYXJkRGV0ZWN0b3IuZ2V0SW5mbyh2YWx1ZSwgcHBzLmNyZWRpdENhcmRTdHJpY3RNb2RlKTtcblxuXHQgICAgICAgIHBwcy5ibG9ja3MgPSBjcmVkaXRDYXJkSW5mby5ibG9ja3M7XG5cdCAgICAgICAgcHBzLmJsb2Nrc0xlbmd0aCA9IHBwcy5ibG9ja3MubGVuZ3RoO1xuXHQgICAgICAgIHBwcy5tYXhMZW5ndGggPSBVdGlsLmdldE1heExlbmd0aChwcHMuYmxvY2tzKTtcblxuXHQgICAgICAgIC8vIGNyZWRpdCBjYXJkIHR5cGUgY2hhbmdlZFxuXHQgICAgICAgIGlmIChwcHMuY3JlZGl0Q2FyZFR5cGUgIT09IGNyZWRpdENhcmRJbmZvLnR5cGUpIHtcblx0ICAgICAgICAgICAgcHBzLmNyZWRpdENhcmRUeXBlID0gY3JlZGl0Q2FyZEluZm8udHlwZTtcblxuXHQgICAgICAgICAgICBwcHMub25DcmVkaXRDYXJkVHlwZUNoYW5nZWQuY2FsbChvd25lciwgcHBzLmNyZWRpdENhcmRUeXBlKTtcblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICB1cGRhdGVWYWx1ZVN0YXRlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAoIW93bmVyLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgb3duZXIuc2V0U3RhdGUoeyB2YWx1ZTogcHBzLnJlc3VsdCB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBlbmRQb3MgPSBvd25lci5lbGVtZW50LnNlbGVjdGlvbkVuZDtcblx0ICAgICAgICB2YXIgb2xkVmFsdWUgPSBvd25lci5lbGVtZW50LnZhbHVlO1xuXHQgICAgICAgIHZhciBuZXdWYWx1ZSA9IHBwcy5yZXN1bHQ7XG5cblx0ICAgICAgICBvd25lci5sYXN0SW5wdXRWYWx1ZSA9IG5ld1ZhbHVlO1xuXG5cdCAgICAgICAgZW5kUG9zID0gVXRpbC5nZXROZXh0Q3Vyc29yUG9zaXRpb24oZW5kUG9zLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblxuXHQgICAgICAgIGlmIChvd25lci5pc0FuZHJvaWQpIHtcblx0ICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgb3duZXIuc2V0U3RhdGUoeyB2YWx1ZTogbmV3VmFsdWUsIGN1cnNvclBvc2l0aW9uOiBlbmRQb3MgfSk7XG5cdCAgICAgICAgICAgIH0sIDEpO1xuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvd25lci5zZXRTdGF0ZSh7IHZhbHVlOiBuZXdWYWx1ZSwgY3Vyc29yUG9zaXRpb246IGVuZFBvcyB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXM7XG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblx0ICAgICAgICB2YXIgX293bmVyJHByb3BzMiA9IG93bmVyLnByb3BzLFxuXHQgICAgICAgICAgICB2YWx1ZSA9IF9vd25lciRwcm9wczIudmFsdWUsXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBfb3duZXIkcHJvcHMyLm9wdGlvbnMsXG5cdCAgICAgICAgICAgIG9uS2V5RG93biA9IF9vd25lciRwcm9wczIub25LZXlEb3duLFxuXHQgICAgICAgICAgICBvbkZvY3VzID0gX293bmVyJHByb3BzMi5vbkZvY3VzLFxuXHQgICAgICAgICAgICBvbkJsdXIgPSBfb3duZXIkcHJvcHMyLm9uQmx1cixcblx0ICAgICAgICAgICAgb25DaGFuZ2UgPSBfb3duZXIkcHJvcHMyLm9uQ2hhbmdlLFxuXHQgICAgICAgICAgICBvbkluaXQgPSBfb3duZXIkcHJvcHMyLm9uSW5pdCxcblx0ICAgICAgICAgICAgaHRtbFJlZiA9IF9vd25lciRwcm9wczIuaHRtbFJlZixcblx0ICAgICAgICAgICAgcHJvcHNUb1RyYW5zZmVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9vd25lciRwcm9wczIsIFsndmFsdWUnLCAnb3B0aW9ucycsICdvbktleURvd24nLCAnb25Gb2N1cycsICdvbkJsdXInLCAnb25DaGFuZ2UnLCAnb25Jbml0JywgJ2h0bWxSZWYnXSk7XG5cblx0ICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBfZXh0ZW5kcyh7XG5cdCAgICAgICAgICAgIHR5cGU6ICd0ZXh0Jyxcblx0ICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZikge1xuXHQgICAgICAgICAgICAgICAgb3duZXIuZWxlbWVudCA9IF9yZWY7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghaHRtbFJlZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaHRtbFJlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICB2YWx1ZTogb3duZXIuc3RhdGUudmFsdWUsXG5cdCAgICAgICAgICAgIG9uS2V5RG93bjogb3duZXIub25LZXlEb3duLFxuXHQgICAgICAgICAgICBvbkNoYW5nZTogb3duZXIub25DaGFuZ2UsXG5cdCAgICAgICAgICAgIG9uRm9jdXM6IG93bmVyLm9uRm9jdXMsXG5cdCAgICAgICAgICAgIG9uQmx1cjogb3duZXIub25CbHVyXG5cdCAgICAgICAgfSwgcHJvcHNUb1RyYW5zZmVyKSk7XG5cdCAgICB9XG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gY2xlYXZlUmVhY3RDbGFzcztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKi9cblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0dmFyIGZhY3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdGlmICh0eXBlb2YgUmVhY3QgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgdGhyb3cgRXJyb3IoXG5cdCAgICAnY3JlYXRlLXJlYWN0LWNsYXNzIGNvdWxkIG5vdCBmaW5kIHRoZSBSZWFjdCBvYmplY3QuIElmIHlvdSBhcmUgdXNpbmcgc2NyaXB0IHRhZ3MsICcgK1xuXHQgICAgICAnbWFrZSBzdXJlIHRoYXQgUmVhY3QgaXMgYmVpbmcgbG9hZGVkIGJlZm9yZSBjcmVhdGUtcmVhY3QtY2xhc3MuJ1xuXHQgICk7XG5cdH1cblxuXHQvLyBIYWNrIHRvIGdyYWIgTm9vcFVwZGF0ZVF1ZXVlIGZyb20gaXNvbW9ycGhpYyBSZWFjdFxuXHR2YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG5cdCAgUmVhY3QuQ29tcG9uZW50LFxuXHQgIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuXHQgIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXG5cdCk7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKi9cblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9hc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBlbXB0eU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBfaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0fVxuXG5cdHZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cblx0Ly8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuXHQvLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXG5cdGZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG5cdCAgcmV0dXJuIGZuO1xuXHR9XG5cblx0dmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuXHQgICAgcHJvcDogJ3Byb3AnLFxuXHQgICAgY29udGV4dDogJ2NvbnRleHQnLFxuXHQgICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcblx0ICB9O1xuXHR9IGVsc2Uge1xuXHQgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cdH1cblxuXHRmdW5jdGlvbiBmYWN0b3J5KFJlYWN0Q29tcG9uZW50LCBpc1ZhbGlkRWxlbWVudCwgUmVhY3ROb29wVXBkYXRlUXVldWUpIHtcblx0ICAvKipcblx0ICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuXHQgICAqL1xuXG5cdCAgdmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cblx0ICAvKipcblx0ICAgKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuXHQgICAqIG9yIGhvc3QgY29tcG9uZW50cy5cblx0ICAgKlxuXHQgICAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2Zcblx0ICAgKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG5cdCAgICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG5cdCAgICpcblx0ICAgKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblx0ICAgKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2Pjtcblx0ICAgKiAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICpcblx0ICAgKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG5cdCAgICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3Jcblx0ICAgKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcblx0ICAgKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG5cdCAgICpcblx0ICAgKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2Vcblx0ICAgKiBAaW50ZXJuYWxcblx0ICAgKi9cblx0ICB2YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG5cdCAgICAgKlxuXHQgICAgICogQHR5cGUge2FycmF5fVxuXHQgICAgICogQG9wdGlvbmFsXG5cdCAgICAgKi9cblx0ICAgIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cblx0ICAgICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cblx0ICAgICAqXG5cdCAgICAgKiBAdHlwZSB7b2JqZWN0fVxuXHQgICAgICogQG9wdGlvbmFsXG5cdCAgICAgKi9cblx0ICAgIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cblx0ICAgICAqXG5cdCAgICAgKiBAdHlwZSB7b2JqZWN0fVxuXHQgICAgICogQG9wdGlvbmFsXG5cdCAgICAgKi9cblx0ICAgIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuXHQgICAgICpcblx0ICAgICAqIEB0eXBlIHtvYmplY3R9XG5cdCAgICAgKiBAb3B0aW9uYWxcblx0ICAgICAqL1xuXHQgICAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG5cdCAgICAvKipcblx0ICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG5cdCAgICAgKlxuXHQgICAgICogQHR5cGUge29iamVjdH1cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuXHQgICAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuXHQgICAgICpcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcblx0ICAgICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge29iamVjdH1cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuXHQgICAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuXHQgICAgICpcblx0ICAgICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcblx0ICAgICAqICAgICByZXR1cm4ge1xuXHQgICAgICogICAgICAgaXNPbjogZmFsc2UsXG5cdCAgICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuXHQgICAgICogICAgIH1cblx0ICAgICAqICAgfVxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge29iamVjdH1cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEByZXR1cm4ge29iamVjdH1cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG5cdCAgICAvKipcblx0ICAgICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcblx0ICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuXHQgICAgICpcblx0ICAgICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cblx0ICAgICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuXHQgICAgICpcblx0ICAgICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblx0ICAgICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcblx0ICAgICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2Pjtcblx0ICAgICAqICAgfVxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuXHQgICAgICogQHJlcXVpcmVkXG5cdCAgICAgKi9cblx0ICAgIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuXHQgICAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cblx0ICAgICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG5cdCAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cblx0ICAgICAqXG5cdCAgICAgKiBAb3B0aW9uYWxcblx0ICAgICAqL1xuXHQgICAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cblx0ICAgICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcblx0ICAgICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cblx0ICAgICAqXG5cdCAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcblx0ICAgICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cblx0ICAgICAqXG5cdCAgICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcblx0ICAgICAqICAgICB0aGlzLnNldFN0YXRlKHtcblx0ICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG5cdCAgICAgKiAgICAgfSk7XG5cdCAgICAgKiAgIH1cblx0ICAgICAqXG5cdCAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuXHQgICAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuXHQgICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuXHQgICAgICogQG9wdGlvbmFsXG5cdCAgICAgKi9cblx0ICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cblx0ICAgIC8qKlxuXHQgICAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG5cdCAgICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cblx0ICAgICAqXG5cdCAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG5cdCAgICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG5cdCAgICAgKiB1cGRhdGUuXG5cdCAgICAgKlxuXHQgICAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuXHQgICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuXHQgICAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcblx0ICAgICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcblx0ICAgICAqICAgfVxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcblx0ICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG5cdCAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG5cdCAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXG5cblx0ICAgIC8qKlxuXHQgICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuXHQgICAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuXHQgICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG5cdCAgICAgKlxuXHQgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cblx0ICAgICAqXG5cdCAgICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuXHQgICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcblx0ICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcblx0ICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcblx0ICAgICAqIGJlZW4gdXBkYXRlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG5cdCAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuXHQgICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuXHQgICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cblx0ICAgIC8qKlxuXHQgICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcblx0ICAgICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuXHQgICAgICpcblx0ICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cblx0ICAgICAqXG5cdCAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cblx0ICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuXHQgICAgICpcblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsTW91bnRgLlxuXHQgICAgICpcblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgLlxuXHQgICAgICpcblx0ICAgICAqIEBvcHRpb25hbFxuXHQgICAgICovXG5cdCAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAb3B0aW9uYWxcblx0ICAgICAqL1xuXHQgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cblx0ICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cblx0ICAgIC8qKlxuXHQgICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuXHQgICAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuXHQgICAgICogQGludGVybmFsXG5cdCAgICAgKiBAb3ZlcnJpZGFibGVcblx0ICAgICAqL1xuXHQgICAgdXBkYXRlQ29tcG9uZW50OiAnT1ZFUlJJREVfQkFTRSdcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogU2ltaWxhciB0byBSZWFjdENsYXNzSW50ZXJmYWNlIGJ1dCBmb3Igc3RhdGljIG1ldGhvZHMuXG5cdCAgICovXG5cdCAgdmFyIFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UgPSB7XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYWZ0ZXIgYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIGFuZCB3aGVuIGl0XG5cdCAgICAgKiByZWNlaXZlcyBuZXcgcHJvcHMuIFJldHVybiBhbiBvYmplY3QgdG8gdXBkYXRlIHN0YXRlIGluIHJlc3BvbnNlIHRvXG5cdCAgICAgKiBwcm9wIGNoYW5nZXMuIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyBrZXlzIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHN0YXRlLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge29iamVjdCB8fCBudWxsfVxuXHQgICAgICogQG9wdGlvbmFsXG5cdCAgICAgKi9cblx0ICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCdcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuXHQgICAqXG5cdCAgICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuXHQgICAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcblx0ICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuXHQgICAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG5cdCAgICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuXHQgICAqL1xuXHQgIHZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG5cdCAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG5cdCAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cdCAgICB9LFxuXHQgICAgbWl4aW5zOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG5cdCAgICAgIGlmIChtaXhpbnMpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuXHQgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcblx0ICAgICAgfVxuXHQgICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG5cdCAgICAgICAge30sXG5cdCAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG5cdCAgICAgICAgY2hpbGRDb250ZXh0VHlwZXNcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcblx0ICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcblx0ICAgICAgfVxuXHQgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuXHQgICAgICAgIHt9LFxuXHQgICAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyxcblx0ICAgICAgICBjb250ZXh0VHlwZXNcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgICAvKipcblx0ICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuXHQgICAgICogYXV0b21hdGljIG1lcmdpbmcuXG5cdCAgICAgKi9cblx0ICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuXHQgICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG5cdCAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oXG5cdCAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG5cdCAgICAgICAgICBnZXREZWZhdWx0UHJvcHNcblx0ICAgICAgICApO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHByb3BUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuXHQgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuXHQgICAgICB9XG5cdCAgICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcblx0ICAgIH0sXG5cdCAgICBzdGF0aWNzOiBmdW5jdGlvbihDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuXHQgICAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG5cdCAgICB9LFxuXHQgICAgYXV0b2JpbmQ6IGZ1bmN0aW9uKCkge31cblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuXHQgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuXHQgICAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcblx0ICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG5cdCAgICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cblx0ICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgICAgd2FybmluZyhcblx0ICAgICAgICAgICAgdHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLFxuXHQgICAgICAgICAgICAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICtcblx0ICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG5cdCAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcblx0ICAgICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLFxuXHQgICAgICAgICAgICBwcm9wTmFtZVxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcblx0ICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHQgICAgICA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV1cblx0ICAgICAgOiBudWxsO1xuXG5cdCAgICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuXHQgICAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHQgICAgICBfaW52YXJpYW50KFxuXHQgICAgICAgIHNwZWNQb2xpY3kgPT09ICdPVkVSUklERV9CQVNFJyxcblx0ICAgICAgICAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgK1xuXHQgICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuXHQgICAgICAgICAgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLFxuXHQgICAgICAgIG5hbWVcblx0ICAgICAgKTtcblx0ICAgIH1cblxuXHQgICAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuXHQgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcblx0ICAgICAgX2ludmFyaWFudChcblx0ICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXHQgICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuXHQgICAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICtcblx0ICAgICAgICAgICd0byBhIG1peGluLicsXG5cdCAgICAgICAgbmFtZVxuXHQgICAgICApO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuXHQgICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcblx0ICAgIGlmICghc3BlYykge1xuXHQgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG5cdCAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cblx0ICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgICAgd2FybmluZyhcblx0ICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuXHQgICAgICAgICAgICBcIiVzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCBcIiArXG5cdCAgICAgICAgICAgICAgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArXG5cdCAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG5cdCAgICAgICAgICAgICAgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsXG5cdCAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcblx0ICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgX2ludmFyaWFudChcblx0ICAgICAgdHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicsXG5cdCAgICAgIFwiUmVhY3RDbGFzczogWW91J3JlIGF0dGVtcHRpbmcgdG8gXCIgK1xuXHQgICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcblx0ICAgICAgICAncmVndWxhciBvYmplY3QuJ1xuXHQgICAgKTtcblx0ICAgIF9pbnZhcmlhbnQoXG5cdCAgICAgICFpc1ZhbGlkRWxlbWVudChzcGVjKSxcblx0ICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG5cdCAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0Lidcblx0ICAgICk7XG5cblx0ICAgIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cblx0ICAgIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuXHQgICAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG5cdCAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cblx0ICAgIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG5cdCAgICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG5cdCAgICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcblx0ICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuXHQgICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHQgICAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG5cdCAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0ICAgICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcblx0ICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcblx0ICAgICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cblx0ICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG5cdCAgICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG5cdCAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG5cdCAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cblx0ICAgICAgICAgIGlzRnVuY3Rpb24gJiZcblx0ICAgICAgICAgICFpc1JlYWN0Q2xhc3NNZXRob2QgJiZcblx0ICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG5cdCAgICAgICAgICBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuXHQgICAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuXHQgICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcblx0ICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuXHQgICAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cblx0ICAgICAgICAgICAgX2ludmFyaWFudChcblx0ICAgICAgICAgICAgICBpc1JlYWN0Q2xhc3NNZXRob2QgJiZcblx0ICAgICAgICAgICAgICAgIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fFxuXHQgICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcblx0ICAgICAgICAgICAgICAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgK1xuXHQgICAgICAgICAgICAgICAgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLFxuXHQgICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG5cdCAgICAgICAgICAgICAgbmFtZVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuXHQgICAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG5cdCAgICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuXHQgICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSB7XG5cdCAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcblx0ICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuXHQgICAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cblx0ICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcblx0ICAgIGlmICghc3RhdGljcykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuXHQgICAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuXHQgICAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG5cdCAgICAgIF9pbnZhcmlhbnQoXG5cdCAgICAgICAgIWlzUmVzZXJ2ZWQsXG5cdCAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcblx0ICAgICAgICAgICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArXG5cdCAgICAgICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcblx0ICAgICAgICAgICdjb25zdHJ1Y3Rvci4nLFxuXHQgICAgICAgIG5hbWVcblx0ICAgICAgKTtcblxuXHQgICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG5cdCAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG5cdCAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpXG5cdCAgICAgICAgICA/IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2VbbmFtZV1cblx0ICAgICAgICAgIDogbnVsbDtcblxuXHQgICAgICAgIF9pbnZhcmlhbnQoXG5cdCAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcblx0ICAgICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuXHQgICAgICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArXG5cdCAgICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuXHQgICAgICAgICAgbmFtZVxuXHQgICAgICAgICk7XG5cblx0ICAgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yW25hbWVdLCBwcm9wZXJ0eSk7XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cblx0ICAgKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG5cdCAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcblx0ICAgIF9pbnZhcmlhbnQoXG5cdCAgICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG5cdCAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nXG5cdCAgICApO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG5cdCAgICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgIF9pbnZhcmlhbnQoXG5cdCAgICAgICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuXHQgICAgICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArXG5cdCAgICAgICAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICtcblx0ICAgICAgICAgICAgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICtcblx0ICAgICAgICAgICAgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArXG5cdCAgICAgICAgICAgICd3aXRoIGNsYXNoaW5nIGtleXMuJyxcblx0ICAgICAgICAgIGtleVxuXHQgICAgICAgICk7XG5cdCAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9uZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cblx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cblx0ICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG5cdCAgICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIGlmIChhID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gYjtcblx0ICAgICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gYTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgYyA9IHt9O1xuXHQgICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuXHQgICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuXHQgICAgICByZXR1cm4gYztcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG5cdCAgICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG5cdCAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcblx0ICAgICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG5cdCAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG5cdCAgICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuXHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcblx0ICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuXHQgICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuXHQgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcblx0ICAgICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcblx0ICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMpIHtcblx0ICAgICAgICBmb3IgKFxuXHQgICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuXHQgICAgICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuXHQgICAgICAgICAgICBfa2V5ID0gMTtcblx0ICAgICAgICAgIF9rZXkgPCBfbGVuO1xuXHQgICAgICAgICAgX2tleSsrXG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuXHQgICAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuXHQgICAgICAgIC8vIGxldCdzIHdhcm4uXG5cdCAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG5cdCAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgICAgICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICtcblx0ICAgICAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsXG5cdCAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgICAgICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArXG5cdCAgICAgICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG5cdCAgICAgICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLFxuXHQgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcblx0ICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG5cdCAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG5cdCAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuXHQgICAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcblx0ICAgIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG5cdCAgICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG5cdCAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBJc01vdW50ZWRQcmVNaXhpbiA9IHtcblx0ICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IHRydWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBJc01vdW50ZWRQb3N0TWl4aW4gPSB7XG5cdCAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHRoaXMuX19pc01vdW50ZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG5cdCAgICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cblx0ICAgKi9cblx0ICB2YXIgUmVhY3RDbGFzc01peGluID0ge1xuXHQgICAgLyoqXG5cdCAgICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcblx0ICAgICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cblx0ICAgICAqL1xuXHQgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSwgY2FsbGJhY2spIHtcblx0ICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuXHQgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAgICAgKiBAcHJvdGVjdGVkXG5cdCAgICAgKiBAZmluYWxcblx0ICAgICAqL1xuXHQgICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsXG5cdCAgICAgICAgICAnJXM6IGlzTW91bnRlZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgJyArXG5cdCAgICAgICAgICAgICdzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvICcgK1xuXHQgICAgICAgICAgICAncHJldmVudCBtZW1vcnkgbGVha3MuJyxcblx0ICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHx8XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSB8fFxuXHQgICAgICAgICAgICAnQ29tcG9uZW50J1xuXHQgICAgICAgICk7XG5cdCAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAhIXRoaXMuX19pc01vdW50ZWQ7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fTtcblx0ICBfYXNzaWduKFxuXHQgICAgUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsXG5cdCAgICBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsXG5cdCAgICBSZWFjdENsYXNzTWl4aW5cblx0ICApO1xuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuXHQgICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuXHQgICAqXG5cdCAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuXHQgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKHNwZWMpIHtcblx0ICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cblx0ICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuXHQgICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cblx0ICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG5cdCAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuXHQgICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cblx0ICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuXHQgICAgICAgICAgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgK1xuXHQgICAgICAgICAgICAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5J1xuXHQgICAgICAgICk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuXHQgICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcblx0ICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuXHQgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHQgICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcblx0ICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXHQgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuXHQgICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG5cdCAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG5cdCAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuXHQgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgIGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmXG5cdCAgICAgICAgICB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb25cblx0ICAgICAgICApIHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG5cdCAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuXHQgICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgX2ludmFyaWFudChcblx0ICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpLFxuXHQgICAgICAgICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLFxuXHQgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcblx0ICAgICAgKTtcblxuXHQgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXHQgICAgfSk7XG5cdCAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuXHQgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cdCAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuXHQgICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cblx0ICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQcmVNaXhpbik7XG5cdCAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cdCAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUG9zdE1peGluKTtcblxuXHQgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cblx0ICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcblx0ICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcblx0ICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcblx0ICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcblx0ICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuXHQgICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG5cdCAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcblx0ICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgX2ludmFyaWFudChcblx0ICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlcixcblx0ICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuXHQgICAgKTtcblxuXHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgd2FybmluZyhcblx0ICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSxcblx0ICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcblx0ICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcblx0ICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG5cdCAgICAgICAgICAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJyxcblx0ICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcblx0ICAgICAgKTtcblx0ICAgICAgd2FybmluZyhcblx0ICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG5cdCAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG5cdCAgICAgICAgICAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsXG5cdCAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG5cdCAgICAgICk7XG5cdCAgICAgIHdhcm5pbmcoXG5cdCAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcblx0ICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiAnICtcblx0ICAgICAgICAgICdEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuXHQgICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuXHQgICAgICApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cblx0ICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuXHQgICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuXHQgICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBjcmVhdGVDbGFzcztcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHRvYmplY3QtYXNzaWduXG5cdChjKSBTaW5kcmUgU29yaHVzXG5cdEBsaWNlbnNlIE1JVFxuXHQqL1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0dmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXHRmdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0XHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBPYmplY3QodmFsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0XHR9KTtcblx0XHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgZnJvbTtcblx0XHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzeW1ib2xzO1xuXG5cdFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICpcblx0ICovXG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqL1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvKipcblx0ICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuXHQgKlxuXHQgKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuXHQgKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcblx0ICogZXhwZWN0aW5nLlxuXHQgKlxuXHQgKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuXHQgKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG5cdCAqL1xuXG5cdHZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG5cdCAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuXHQgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICB2YXIgZXJyb3I7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuXHQgICAgICB2YXIgYXJnSW5kZXggPSAwO1xuXHQgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuXHQgICAgICB9KSk7XG5cdCAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG5cdCAgICB9XG5cblx0ICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcblx0ICAgIHRocm93IGVycm9yO1xuXHQgIH1cblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqL1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cblx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuXHQgKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuXHQgKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cblx0ICovXG5cblx0dmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGFyZ0luZGV4ID0gMDtcblx0ICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcblx0ICAgIH0pO1xuXHQgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuXHQgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcblx0ICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgIH0gY2F0Y2ggKHgpIHt9XG5cdCAgfTtcblxuXHQgIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuXHQgICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG5cdCAgICB9XG5cblx0ICAgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcblx0ICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqIFxuXHQgKi9cblxuXHRmdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGFyZztcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG5cdCAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG5cdCAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG5cdCAqL1xuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICByZXR1cm4gYXJnO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBOdW1lcmFsRm9ybWF0dGVyID0gZnVuY3Rpb24gTnVtZXJhbEZvcm1hdHRlcihudW1lcmFsRGVjaW1hbE1hcmssIG51bWVyYWxJbnRlZ2VyU2NhbGUsIG51bWVyYWxEZWNpbWFsU2NhbGUsIG51bWVyYWxUaG91c2FuZHNHcm91cFN0eWxlLCBudW1lcmFsUG9zaXRpdmVPbmx5LCBzdHJpcExlYWRpbmdaZXJvZXMsIHByZWZpeCwgc2lnbkJlZm9yZVByZWZpeCwgdGFpbFByZWZpeCwgZGVsaW1pdGVyKSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICBvd25lci5udW1lcmFsRGVjaW1hbE1hcmsgPSBudW1lcmFsRGVjaW1hbE1hcmsgfHwgJy4nO1xuXHQgICAgb3duZXIubnVtZXJhbEludGVnZXJTY2FsZSA9IG51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwID8gbnVtZXJhbEludGVnZXJTY2FsZSA6IDA7XG5cdCAgICBvd25lci5udW1lcmFsRGVjaW1hbFNjYWxlID0gbnVtZXJhbERlY2ltYWxTY2FsZSA+PSAwID8gbnVtZXJhbERlY2ltYWxTY2FsZSA6IDI7XG5cdCAgICBvd25lci5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSA9IG51bWVyYWxUaG91c2FuZHNHcm91cFN0eWxlIHx8IE51bWVyYWxGb3JtYXR0ZXIuZ3JvdXBTdHlsZS50aG91c2FuZDtcblx0ICAgIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPSAhIW51bWVyYWxQb3NpdGl2ZU9ubHk7XG5cdCAgICBvd25lci5zdHJpcExlYWRpbmdaZXJvZXMgPSBzdHJpcExlYWRpbmdaZXJvZXMgIT09IGZhbHNlO1xuXHQgICAgb3duZXIucHJlZml4ID0gcHJlZml4IHx8IHByZWZpeCA9PT0gJycgPyBwcmVmaXggOiAnJztcblx0ICAgIG93bmVyLnNpZ25CZWZvcmVQcmVmaXggPSAhIXNpZ25CZWZvcmVQcmVmaXg7XG5cdCAgICBvd25lci50YWlsUHJlZml4ID0gISF0YWlsUHJlZml4O1xuXHQgICAgb3duZXIuZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IGRlbGltaXRlciA9PT0gJycgPyBkZWxpbWl0ZXIgOiAnLCc7XG5cdCAgICBvd25lci5kZWxpbWl0ZXJSRSA9IGRlbGltaXRlciA/IG5ldyBSZWdFeHAoJ1xcXFwnICsgZGVsaW1pdGVyLCAnZycpIDogJyc7XG5cdH07XG5cblx0TnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlID0ge1xuXHQgICAgdGhvdXNhbmQ6ICd0aG91c2FuZCcsXG5cdCAgICBsYWtoOiAnbGFraCcsXG5cdCAgICB3YW46ICd3YW4nLFxuXHQgICAgbm9uZTogJ25vbmUnXG5cdH07XG5cblx0TnVtZXJhbEZvcm1hdHRlci5wcm90b3R5cGUgPSB7XG5cdCAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gZ2V0UmF3VmFsdWUodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLmRlbGltaXRlclJFLCAnJykucmVwbGFjZSh0aGlzLm51bWVyYWxEZWNpbWFsTWFyaywgJy4nKTtcblx0ICAgIH0sXG5cblx0ICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgcGFydHMsXG5cdCAgICAgICAgICAgIHBhcnRTaWduLFxuXHQgICAgICAgICAgICBwYXJ0U2lnbkFuZFByZWZpeCxcblx0ICAgICAgICAgICAgcGFydEludGVnZXIsXG5cdCAgICAgICAgICAgIHBhcnREZWNpbWFsID0gJyc7XG5cblx0ICAgICAgICAvLyBzdHJpcCBhbHBoYWJldCBsZXR0ZXJzXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bQS1aYS16XS9nLCAnJylcblx0ICAgICAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBkZWNpbWFsIG1hcmsgd2l0aCByZXNlcnZlZCBwbGFjZWhvbGRlclxuXHQgICAgICAgIC5yZXBsYWNlKG93bmVyLm51bWVyYWxEZWNpbWFsTWFyaywgJ00nKVxuXG5cdCAgICAgICAgLy8gc3RyaXAgbm9uIG51bWVyaWMgbGV0dGVycyBleGNlcHQgbWludXMgYW5kIFwiTVwiXG5cdCAgICAgICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgcHJlZml4IGhhcyBiZWVuIHN0cmlwcGVkXG5cdCAgICAgICAgLnJlcGxhY2UoL1teXFxkTS1dL2csICcnKVxuXG5cdCAgICAgICAgLy8gcmVwbGFjZSB0aGUgbGVhZGluZyBtaW51cyB3aXRoIHJlc2VydmVkIHBsYWNlaG9sZGVyXG5cdCAgICAgICAgLnJlcGxhY2UoL15cXC0vLCAnTicpXG5cblx0ICAgICAgICAvLyBzdHJpcCB0aGUgb3RoZXIgbWludXMgc2lnbiAoaWYgcHJlc2VudClcblx0ICAgICAgICAucmVwbGFjZSgvXFwtL2csICcnKVxuXG5cdCAgICAgICAgLy8gcmVwbGFjZSB0aGUgbWludXMgc2lnbiAoaWYgcHJlc2VudClcblx0ICAgICAgICAucmVwbGFjZSgnTicsIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPyAnJyA6ICctJylcblxuXHQgICAgICAgIC8vIHJlcGxhY2UgZGVjaW1hbCBtYXJrXG5cdCAgICAgICAgLnJlcGxhY2UoJ00nLCBvd25lci5udW1lcmFsRGVjaW1hbE1hcmspO1xuXG5cdCAgICAgICAgLy8gc3RyaXAgYW55IGxlYWRpbmcgemVyb3Ncblx0ICAgICAgICBpZiAob3duZXIuc3RyaXBMZWFkaW5nWmVyb2VzKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXigtKT8wKyg/PVxcZCkvLCAnJDEnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwYXJ0U2lnbiA9IHZhbHVlLnNsaWNlKDAsIDEpID09PSAnLScgPyAnLScgOiAnJztcblx0ICAgICAgICBpZiAodHlwZW9mIG93bmVyLnByZWZpeCAhPSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICBpZiAob3duZXIuc2lnbkJlZm9yZVByZWZpeCkge1xuXHQgICAgICAgICAgICAgICAgcGFydFNpZ25BbmRQcmVmaXggPSBwYXJ0U2lnbiArIG93bmVyLnByZWZpeDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHBhcnRTaWduQW5kUHJlZml4ID0gb3duZXIucHJlZml4ICsgcGFydFNpZ247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBwYXJ0U2lnbkFuZFByZWZpeCA9IHBhcnRTaWduO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBhcnRJbnRlZ2VyID0gdmFsdWU7XG5cblx0ICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihvd25lci5udW1lcmFsRGVjaW1hbE1hcmspID49IDApIHtcblx0ICAgICAgICAgICAgcGFydHMgPSB2YWx1ZS5zcGxpdChvd25lci5udW1lcmFsRGVjaW1hbE1hcmspO1xuXHQgICAgICAgICAgICBwYXJ0SW50ZWdlciA9IHBhcnRzWzBdO1xuXHQgICAgICAgICAgICBwYXJ0RGVjaW1hbCA9IG93bmVyLm51bWVyYWxEZWNpbWFsTWFyayArIHBhcnRzWzFdLnNsaWNlKDAsIG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwYXJ0U2lnbiA9PT0gJy0nKSB7XG5cdCAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIuc2xpY2UoMSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG93bmVyLm51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwKSB7XG5cdCAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIuc2xpY2UoMCwgb3duZXIubnVtZXJhbEludGVnZXJTY2FsZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3dpdGNoIChvd25lci5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSkge1xuXHQgICAgICAgICAgICBjYXNlIE51bWVyYWxGb3JtYXR0ZXIuZ3JvdXBTdHlsZS5sYWtoOlxuXHQgICAgICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0SW50ZWdlci5yZXBsYWNlKC8oXFxkKSg/PShcXGRcXGQpK1xcZCQpL2csICckMScgKyBvd25lci5kZWxpbWl0ZXIpO1xuXG5cdCAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlIE51bWVyYWxGb3JtYXR0ZXIuZ3JvdXBTdHlsZS53YW46XG5cdCAgICAgICAgICAgICAgICBwYXJ0SW50ZWdlciA9IHBhcnRJbnRlZ2VyLnJlcGxhY2UoLyhcXGQpKD89KFxcZHs0fSkrJCkvZywgJyQxJyArIG93bmVyLmRlbGltaXRlcik7XG5cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgTnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlLnRob3VzYW5kOlxuXHQgICAgICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0SW50ZWdlci5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyQpL2csICckMScgKyBvd25lci5kZWxpbWl0ZXIpO1xuXG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3duZXIudGFpbFByZWZpeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGFydFNpZ24gKyBwYXJ0SW50ZWdlci50b1N0cmluZygpICsgKG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUgPiAwID8gcGFydERlY2ltYWwudG9TdHJpbmcoKSA6ICcnKSArIG93bmVyLnByZWZpeDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGFydFNpZ25BbmRQcmVmaXggKyBwYXJ0SW50ZWdlci50b1N0cmluZygpICsgKG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUgPiAwID8gcGFydERlY2ltYWwudG9TdHJpbmcoKSA6ICcnKTtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IE51bWVyYWxGb3JtYXR0ZXI7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIERhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiBEYXRlRm9ybWF0dGVyKGRhdGVQYXR0ZXJuLCBkYXRlTWluLCBkYXRlTWF4KSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICBvd25lci5kYXRlID0gW107XG5cdCAgICBvd25lci5ibG9ja3MgPSBbXTtcblx0ICAgIG93bmVyLmRhdGVQYXR0ZXJuID0gZGF0ZVBhdHRlcm47XG5cdCAgICBvd25lci5kYXRlTWluID0gZGF0ZU1pbi5zcGxpdCgnLScpLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuXHQgICAgfSk7XG5cdCAgICBpZiAob3duZXIuZGF0ZU1pbi5sZW5ndGggPT09IDIpIG93bmVyLmRhdGVNaW4udW5zaGlmdCgwKTtcblxuXHQgICAgb3duZXIuZGF0ZU1heCA9IGRhdGVNYXguc3BsaXQoJy0nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcblx0ICAgIH0pO1xuXHQgICAgaWYgKG93bmVyLmRhdGVNYXgubGVuZ3RoID09PSAyKSBvd25lci5kYXRlTWF4LnVuc2hpZnQoMCk7XG5cblx0ICAgIG93bmVyLmluaXRCbG9ja3MoKTtcblx0fTtcblxuXHREYXRlRm9ybWF0dGVyLnByb3RvdHlwZSA9IHtcblx0ICAgIGluaXRCbG9ja3M6IGZ1bmN0aW9uIGluaXRCbG9ja3MoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblx0ICAgICAgICBvd25lci5kYXRlUGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdZJykge1xuXHQgICAgICAgICAgICAgICAgb3duZXIuYmxvY2tzLnB1c2goNCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvd25lci5ibG9ja3MucHVzaCgyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0SVNPRm9ybWF0RGF0ZTogZnVuY3Rpb24gZ2V0SVNPRm9ybWF0RGF0ZSgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBkYXRlID0gb3duZXIuZGF0ZTtcblxuXHQgICAgICAgIHJldHVybiBkYXRlWzJdID8gZGF0ZVsyXSArICctJyArIG93bmVyLmFkZExlYWRpbmdaZXJvKGRhdGVbMV0pICsgJy0nICsgb3duZXIuYWRkTGVhZGluZ1plcm8oZGF0ZVswXSkgOiAnJztcblx0ICAgIH0sXG5cblx0ICAgIGdldEJsb2NrczogZnVuY3Rpb24gZ2V0QmxvY2tzKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmJsb2Nrcztcblx0ICAgIH0sXG5cblx0ICAgIGdldFZhbGlkYXRlZERhdGU6IGZ1bmN0aW9uIGdldFZhbGlkYXRlZERhdGUodmFsdWUpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICByZXN1bHQgPSAnJztcblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXGRdL2csICcnKTtcblxuXHQgICAgICAgIG93bmVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcblx0ICAgICAgICAgICAgICAgICAgICBzdWIwID0gc3ViLnNsaWNlKDAsIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB2YWx1ZS5zbGljZShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKG93bmVyLmRhdGVQYXR0ZXJuW2luZGV4XSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViID09PSAnMDAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMDEnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YjAsIDEwKSA+IDMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwJyArIHN1YjA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQoc3ViLCAxMCkgPiAzMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzMxJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWIgPT09ICcwMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwMSc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQoc3ViMCwgMTApID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAnICsgc3ViMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIsIDEwKSA+IDEyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMTInO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdWI7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSByZW1haW5pbmcgc3RyaW5nXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3Q7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkRGF0ZVN0cmluZyhyZXN1bHQpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0Rml4ZWREYXRlU3RyaW5nOiBmdW5jdGlvbiBnZXRGaXhlZERhdGVTdHJpbmcodmFsdWUpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBkYXRlUGF0dGVybiA9IG93bmVyLmRhdGVQYXR0ZXJuLFxuXHQgICAgICAgICAgICBkYXRlID0gW10sXG5cdCAgICAgICAgICAgIGRheUluZGV4ID0gMCxcblx0ICAgICAgICAgICAgbW9udGhJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIHllYXJJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIGRheVN0YXJ0SW5kZXggPSAwLFxuXHQgICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSAwLFxuXHQgICAgICAgICAgICB5ZWFyU3RhcnRJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIGRheSxcblx0ICAgICAgICAgICAgbW9udGgsXG5cdCAgICAgICAgICAgIHllYXIsXG5cdCAgICAgICAgICAgIGZ1bGxZZWFyRG9uZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgLy8gbW0tZGQgfHwgZGQtbW1cblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSA0ICYmIGRhdGVQYXR0ZXJuWzBdLnRvTG93ZXJDYXNlKCkgIT09ICd5JyAmJiBkYXRlUGF0dGVyblsxXS50b0xvd2VyQ2FzZSgpICE9PSAneScpIHtcblx0ICAgICAgICAgICAgZGF5U3RhcnRJbmRleCA9IGRhdGVQYXR0ZXJuWzBdID09PSAnZCcgPyAwIDogMjtcblx0ICAgICAgICAgICAgbW9udGhTdGFydEluZGV4ID0gMiAtIGRheVN0YXJ0SW5kZXg7XG5cdCAgICAgICAgICAgIGRheSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGRheVN0YXJ0SW5kZXgsIGRheVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1vbnRoU3RhcnRJbmRleCwgbW9udGhTdGFydEluZGV4ICsgMiksIDEwKTtcblxuXHQgICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRGaXhlZERhdGUoZGF5LCBtb250aCwgMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8geXl5eS1tbS1kZCB8fCB5eXl5LWRkLW1tIHx8IG1tLWRkLXl5eXkgfHwgZGQtbW0teXl5eSB8fCBkZC15eXl5LW1tIHx8IG1tLXl5eXktZGRcblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSA4KSB7XG5cdCAgICAgICAgICAgIGRhdGVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXggPSBpbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoSW5kZXggPSBpbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeWVhckluZGV4ID0gaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB5ZWFyU3RhcnRJbmRleCA9IHllYXJJbmRleCAqIDI7XG5cdCAgICAgICAgICAgIGRheVN0YXJ0SW5kZXggPSBkYXlJbmRleCA8PSB5ZWFySW5kZXggPyBkYXlJbmRleCAqIDIgOiBkYXlJbmRleCAqIDIgKyAyO1xuXHQgICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSBtb250aEluZGV4IDw9IHllYXJJbmRleCA/IG1vbnRoSW5kZXggKiAyIDogbW9udGhJbmRleCAqIDIgKyAyO1xuXG5cdCAgICAgICAgICAgIGRheSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGRheVN0YXJ0SW5kZXgsIGRheVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1vbnRoU3RhcnRJbmRleCwgbW9udGhTdGFydEluZGV4ICsgMiksIDEwKTtcblx0ICAgICAgICAgICAgeWVhciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDQpLCAxMCk7XG5cblx0ICAgICAgICAgICAgZnVsbFllYXJEb25lID0gdmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgNCkubGVuZ3RoID09PSA0O1xuXG5cdCAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldEZpeGVkRGF0ZShkYXksIG1vbnRoLCB5ZWFyKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBtbS15eSB8fCB5eS1tbVxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgKGRhdGVQYXR0ZXJuWzBdID09PSAneScgfHwgZGF0ZVBhdHRlcm5bMV0gPT09ICd5JykpIHtcblx0ICAgICAgICAgICAgbW9udGhTdGFydEluZGV4ID0gZGF0ZVBhdHRlcm5bMF0gPT09ICdtJyA/IDAgOiAyO1xuXHQgICAgICAgICAgICB5ZWFyU3RhcnRJbmRleCA9IDIgLSBtb250aFN0YXJ0SW5kZXg7XG5cdCAgICAgICAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc2xpY2UobW9udGhTdGFydEluZGV4LCBtb250aFN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgMiksIDEwKTtcblxuXHQgICAgICAgICAgICBmdWxsWWVhckRvbmUgPSB2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyAyKS5sZW5ndGggPT09IDI7XG5cblx0ICAgICAgICAgICAgZGF0ZSA9IFswLCBtb250aCwgeWVhcl07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gbW0teXl5eSB8fCB5eXl5LW1tXG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNiAmJiAoZGF0ZVBhdHRlcm5bMF0gPT09ICdZJyB8fCBkYXRlUGF0dGVyblsxXSA9PT0gJ1knKSkge1xuXHQgICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSBkYXRlUGF0dGVyblswXSA9PT0gJ20nID8gMCA6IDQ7XG5cdCAgICAgICAgICAgIHllYXJTdGFydEluZGV4ID0gMiAtIDAuNSAqIG1vbnRoU3RhcnRJbmRleDtcblx0ICAgICAgICAgICAgbW9udGggPSBwYXJzZUludCh2YWx1ZS5zbGljZShtb250aFN0YXJ0SW5kZXgsIG1vbnRoU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cdCAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyA0KSwgMTApO1xuXG5cdCAgICAgICAgICAgIGZ1bGxZZWFyRG9uZSA9IHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDQpLmxlbmd0aCA9PT0gNDtcblxuXHQgICAgICAgICAgICBkYXRlID0gWzAsIG1vbnRoLCB5ZWFyXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkYXRlID0gb3duZXIuZ2V0UmFuZ2VGaXhlZERhdGUoZGF0ZSk7XG5cdCAgICAgICAgb3duZXIuZGF0ZSA9IGRhdGU7XG5cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gZGF0ZS5sZW5ndGggPT09IDAgPyB2YWx1ZSA6IGRhdGVQYXR0ZXJuLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdkJzpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyAoZGF0ZVswXSA9PT0gMCA/ICcnIDogb3duZXIuYWRkTGVhZGluZ1plcm8oZGF0ZVswXSkpO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgKGRhdGVbMV0gPT09IDAgPyAnJyA6IG93bmVyLmFkZExlYWRpbmdaZXJvKGRhdGVbMV0pKTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3knOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIChmdWxsWWVhckRvbmUgPyBvd25lci5hZGRMZWFkaW5nWmVyb0ZvclllYXIoZGF0ZVsyXSwgZmFsc2UpIDogJycpO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnWSc6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgKGZ1bGxZZWFyRG9uZSA/IG93bmVyLmFkZExlYWRpbmdaZXJvRm9yWWVhcihkYXRlWzJdLCB0cnVlKSA6ICcnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sICcnKTtcblxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRSYW5nZUZpeGVkRGF0ZTogZnVuY3Rpb24gZ2V0UmFuZ2VGaXhlZERhdGUoZGF0ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIGRhdGVQYXR0ZXJuID0gb3duZXIuZGF0ZVBhdHRlcm4sXG5cdCAgICAgICAgICAgIGRhdGVNaW4gPSBvd25lci5kYXRlTWluIHx8IFtdLFxuXHQgICAgICAgICAgICBkYXRlTWF4ID0gb3duZXIuZGF0ZU1heCB8fCBbXTtcblxuXHQgICAgICAgIGlmICghZGF0ZS5sZW5ndGggfHwgZGF0ZU1pbi5sZW5ndGggPCAzICYmIGRhdGVNYXgubGVuZ3RoIDwgMykgcmV0dXJuIGRhdGU7XG5cblx0ICAgICAgICBpZiAoZGF0ZVBhdHRlcm4uZmluZChmdW5jdGlvbiAoeCkge1xuXHQgICAgICAgICAgICByZXR1cm4geC50b0xvd2VyQ2FzZSgpID09PSAneSc7XG5cdCAgICAgICAgfSkgJiYgZGF0ZVsyXSA9PT0gMCkgcmV0dXJuIGRhdGU7XG5cblx0ICAgICAgICBpZiAoZGF0ZU1heC5sZW5ndGggJiYgKGRhdGVNYXhbMl0gPCBkYXRlWzJdIHx8IGRhdGVNYXhbMl0gPT09IGRhdGVbMl0gJiYgKGRhdGVNYXhbMV0gPCBkYXRlWzFdIHx8IGRhdGVNYXhbMV0gPT09IGRhdGVbMV0gJiYgZGF0ZU1heFswXSA8IGRhdGVbMF0pKSkgcmV0dXJuIGRhdGVNYXg7XG5cblx0ICAgICAgICBpZiAoZGF0ZU1pbi5sZW5ndGggJiYgKGRhdGVNaW5bMl0gPiBkYXRlWzJdIHx8IGRhdGVNaW5bMl0gPT09IGRhdGVbMl0gJiYgKGRhdGVNaW5bMV0gPiBkYXRlWzFdIHx8IGRhdGVNaW5bMV0gPT09IGRhdGVbMV0gJiYgZGF0ZU1pblswXSA+IGRhdGVbMF0pKSkgcmV0dXJuIGRhdGVNaW47XG5cblx0ICAgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkRGF0ZTogZnVuY3Rpb24gZ2V0Rml4ZWREYXRlKGRheSwgbW9udGgsIHllYXIpIHtcblx0ICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIDMxKTtcblx0ICAgICAgICBtb250aCA9IE1hdGgubWluKG1vbnRoLCAxMik7XG5cdCAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIgfHwgMCwgMTApO1xuXG5cdCAgICAgICAgaWYgKG1vbnRoIDwgNyAmJiBtb250aCAlIDIgPT09IDAgfHwgbW9udGggPiA4ICYmIG1vbnRoICUgMiA9PT0gMSkge1xuXHQgICAgICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIG1vbnRoID09PSAyID8gdGhpcy5pc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCA6IDMwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gW2RheSwgbW9udGgsIHllYXJdO1xuXHQgICAgfSxcblxuXHQgICAgaXNMZWFwWWVhcjogZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG5cdCAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcblx0ICAgIH0sXG5cblx0ICAgIGFkZExlYWRpbmdaZXJvOiBmdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW1iZXIpIHtcblx0ICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAnIDogJycpICsgbnVtYmVyO1xuXHQgICAgfSxcblxuXHQgICAgYWRkTGVhZGluZ1plcm9Gb3JZZWFyOiBmdW5jdGlvbiBhZGRMZWFkaW5nWmVyb0ZvclllYXIobnVtYmVyLCBmdWxsWWVhck1vZGUpIHtcblx0ICAgICAgICBpZiAoZnVsbFllYXJNb2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAobnVtYmVyIDwgMTAgPyAnMDAwJyA6IG51bWJlciA8IDEwMCA/ICcwMCcgOiBudW1iZXIgPCAxMDAwID8gJzAnIDogJycpICsgbnVtYmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiAobnVtYmVyIDwgMTAgPyAnMCcgOiAnJykgKyBudW1iZXI7XG5cdCAgICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBEYXRlRm9ybWF0dGVyO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBUaW1lRm9ybWF0dGVyID0gZnVuY3Rpb24gVGltZUZvcm1hdHRlcih0aW1lUGF0dGVybiwgdGltZUZvcm1hdCkge1xuXHQgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgb3duZXIudGltZSA9IFtdO1xuXHQgICAgb3duZXIuYmxvY2tzID0gW107XG5cdCAgICBvd25lci50aW1lUGF0dGVybiA9IHRpbWVQYXR0ZXJuO1xuXHQgICAgb3duZXIudGltZUZvcm1hdCA9IHRpbWVGb3JtYXQ7XG5cdCAgICBvd25lci5pbml0QmxvY2tzKCk7XG5cdH07XG5cblx0VGltZUZvcm1hdHRlci5wcm90b3R5cGUgPSB7XG5cdCAgICBpbml0QmxvY2tzOiBmdW5jdGlvbiBpbml0QmxvY2tzKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXM7XG5cdCAgICAgICAgb3duZXIudGltZVBhdHRlcm4uZm9yRWFjaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIG93bmVyLmJsb2Nrcy5wdXNoKDIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0SVNPRm9ybWF0VGltZTogZnVuY3Rpb24gZ2V0SVNPRm9ybWF0VGltZSgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICB0aW1lID0gb3duZXIudGltZTtcblxuXHQgICAgICAgIHJldHVybiB0aW1lWzJdID8gb3duZXIuYWRkTGVhZGluZ1plcm8odGltZVswXSkgKyAnOicgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzFdKSArICc6JyArIG93bmVyLmFkZExlYWRpbmdaZXJvKHRpbWVbMl0pIDogJyc7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRCbG9ja3M6IGZ1bmN0aW9uIGdldEJsb2NrcygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5ibG9ja3M7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRUaW1lRm9ybWF0T3B0aW9uczogZnVuY3Rpb24gZ2V0VGltZUZvcm1hdE9wdGlvbnMoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblx0ICAgICAgICBpZiAoU3RyaW5nKG93bmVyLnRpbWVGb3JtYXQpID09PSAnMTInKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBtYXhIb3VyRmlyc3REaWdpdDogMSxcblx0ICAgICAgICAgICAgICAgIG1heEhvdXJzOiAxMixcblx0ICAgICAgICAgICAgICAgIG1heE1pbnV0ZXNGaXJzdERpZ2l0OiA1LFxuXHQgICAgICAgICAgICAgICAgbWF4TWludXRlczogNjBcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBtYXhIb3VyRmlyc3REaWdpdDogMixcblx0ICAgICAgICAgICAgbWF4SG91cnM6IDIzLFxuXHQgICAgICAgICAgICBtYXhNaW51dGVzRmlyc3REaWdpdDogNSxcblx0ICAgICAgICAgICAgbWF4TWludXRlczogNjBcblx0ICAgICAgICB9O1xuXHQgICAgfSxcblxuXHQgICAgZ2V0VmFsaWRhdGVkVGltZTogZnVuY3Rpb24gZ2V0VmFsaWRhdGVkVGltZSh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG5cdCAgICAgICAgdmFyIHRpbWVGb3JtYXRPcHRpb25zID0gb3duZXIuZ2V0VGltZUZvcm1hdE9wdGlvbnMoKTtcblxuXHQgICAgICAgIG93bmVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcblx0ICAgICAgICAgICAgICAgICAgICBzdWIwID0gc3ViLnNsaWNlKDAsIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB2YWx1ZS5zbGljZShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKG93bmVyLnRpbWVQYXR0ZXJuW2luZGV4XSkge1xuXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChzdWIwLCAxMCkgPiB0aW1lRm9ybWF0T3B0aW9ucy5tYXhIb3VyRmlyc3REaWdpdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAnICsgc3ViMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIsIDEwKSA+IHRpbWVGb3JtYXRPcHRpb25zLm1heEhvdXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSB0aW1lRm9ybWF0T3B0aW9ucy5tYXhIb3VycyArICcnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHN1YjAsIDEwKSA+IHRpbWVGb3JtYXRPcHRpb25zLm1heE1pbnV0ZXNGaXJzdERpZ2l0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSAnMCcgKyBzdWIwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4TWludXRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gdGltZUZvcm1hdE9wdGlvbnMubWF4TWludXRlcyArICcnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3ViO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcmVtYWluaW5nIHN0cmluZ1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXhlZFRpbWVTdHJpbmcocmVzdWx0KTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkVGltZVN0cmluZzogZnVuY3Rpb24gZ2V0Rml4ZWRUaW1lU3RyaW5nKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcyxcblx0ICAgICAgICAgICAgdGltZVBhdHRlcm4gPSBvd25lci50aW1lUGF0dGVybixcblx0ICAgICAgICAgICAgdGltZSA9IFtdLFxuXHQgICAgICAgICAgICBzZWNvbmRJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIG1pbnV0ZUluZGV4ID0gMCxcblx0ICAgICAgICAgICAgaG91ckluZGV4ID0gMCxcblx0ICAgICAgICAgICAgc2Vjb25kU3RhcnRJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIG1pbnV0ZVN0YXJ0SW5kZXggPSAwLFxuXHQgICAgICAgICAgICBob3VyU3RhcnRJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIHNlY29uZCxcblx0ICAgICAgICAgICAgbWludXRlLFxuXHQgICAgICAgICAgICBob3VyO1xuXG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNikge1xuXHQgICAgICAgICAgICB0aW1lUGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEluZGV4ID0gaW5kZXggKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlSW5kZXggPSBpbmRleCAqIDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBob3VySW5kZXggPSBpbmRleCAqIDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBob3VyU3RhcnRJbmRleCA9IGhvdXJJbmRleDtcblx0ICAgICAgICAgICAgbWludXRlU3RhcnRJbmRleCA9IG1pbnV0ZUluZGV4O1xuXHQgICAgICAgICAgICBzZWNvbmRTdGFydEluZGV4ID0gc2Vjb25kSW5kZXg7XG5cblx0ICAgICAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQodmFsdWUuc2xpY2Uoc2Vjb25kU3RhcnRJbmRleCwgc2Vjb25kU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cdCAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1pbnV0ZVN0YXJ0SW5kZXgsIG1pbnV0ZVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICBob3VyID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoaG91clN0YXJ0SW5kZXgsIGhvdXJTdGFydEluZGV4ICsgMiksIDEwKTtcblxuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy5nZXRGaXhlZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgb3duZXIudGltZVBhdHRlcm4uaW5kZXhPZigncycpIDwgMCkge1xuXHQgICAgICAgICAgICB0aW1lUGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZUluZGV4ID0gaW5kZXggKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaG91ckluZGV4ID0gaW5kZXggKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgaG91clN0YXJ0SW5kZXggPSBob3VySW5kZXg7XG5cdCAgICAgICAgICAgIG1pbnV0ZVN0YXJ0SW5kZXggPSBtaW51dGVJbmRleDtcblxuXHQgICAgICAgICAgICBzZWNvbmQgPSAwO1xuXHQgICAgICAgICAgICBtaW51dGUgPSBwYXJzZUludCh2YWx1ZS5zbGljZShtaW51dGVTdGFydEluZGV4LCBtaW51dGVTdGFydEluZGV4ICsgMiksIDEwKTtcblx0ICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGhvdXJTdGFydEluZGV4LCBob3VyU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMuZ2V0Rml4ZWRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvd25lci50aW1lID0gdGltZTtcblxuXHQgICAgICAgIHJldHVybiB0aW1lLmxlbmd0aCA9PT0gMCA/IHZhbHVlIDogdGltZVBhdHRlcm4ucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIG93bmVyLmFkZExlYWRpbmdaZXJvKHRpbWVbMl0pO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgb3duZXIuYWRkTGVhZGluZ1plcm8odGltZVsxXSk7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdoJzpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sICcnKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkVGltZTogZnVuY3Rpb24gZ2V0Rml4ZWRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSB7XG5cdCAgICAgICAgc2Vjb25kID0gTWF0aC5taW4ocGFyc2VJbnQoc2Vjb25kIHx8IDAsIDEwKSwgNjApO1xuXHQgICAgICAgIG1pbnV0ZSA9IE1hdGgubWluKG1pbnV0ZSwgNjApO1xuXHQgICAgICAgIGhvdXIgPSBNYXRoLm1pbihob3VyLCA2MCk7XG5cblx0ICAgICAgICByZXR1cm4gW2hvdXIsIG1pbnV0ZSwgc2Vjb25kXTtcblx0ICAgIH0sXG5cblx0ICAgIGFkZExlYWRpbmdaZXJvOiBmdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW1iZXIpIHtcblx0ICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAnIDogJycpICsgbnVtYmVyO1xuXHQgICAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gVGltZUZvcm1hdHRlcjtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgUGhvbmVGb3JtYXR0ZXIgPSBmdW5jdGlvbiBQaG9uZUZvcm1hdHRlcihmb3JtYXR0ZXIsIGRlbGltaXRlcikge1xuXHQgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgb3duZXIuZGVsaW1pdGVyID0gZGVsaW1pdGVyIHx8IGRlbGltaXRlciA9PT0gJycgPyBkZWxpbWl0ZXIgOiAnICc7XG5cdCAgICBvd25lci5kZWxpbWl0ZXJSRSA9IGRlbGltaXRlciA/IG5ldyBSZWdFeHAoJ1xcXFwnICsgZGVsaW1pdGVyLCAnZycpIDogJyc7XG5cblx0ICAgIG93bmVyLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcblx0fTtcblxuXHRQaG9uZUZvcm1hdHRlci5wcm90b3R5cGUgPSB7XG5cdCAgICBzZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uIHNldEZvcm1hdHRlcihmb3JtYXR0ZXIpIHtcblx0ICAgICAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcblx0ICAgIH0sXG5cblx0ICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBob25lTnVtYmVyKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgICAgIG93bmVyLmZvcm1hdHRlci5jbGVhcigpO1xuXG5cdCAgICAgICAgLy8gb25seSBrZWVwIG51bWJlciBhbmQgK1xuXHQgICAgICAgIHBob25lTnVtYmVyID0gcGhvbmVOdW1iZXIucmVwbGFjZSgvW15cXGQrXS9nLCAnJyk7XG5cblx0ICAgICAgICAvLyBzdHJpcCBub24tbGVhZGluZyArXG5cdCAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKC9eXFwrLywgJ0InKS5yZXBsYWNlKC9cXCsvZywgJycpLnJlcGxhY2UoJ0InLCAnKycpO1xuXG5cdCAgICAgICAgLy8gc3RyaXAgZGVsaW1pdGVyXG5cdCAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKG93bmVyLmRlbGltaXRlclJFLCAnJyk7XG5cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG5cdCAgICAgICAgICAgIGN1cnJlbnQsXG5cdCAgICAgICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlNYXggPSBwaG9uZU51bWJlci5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcblx0ICAgICAgICAgICAgY3VycmVudCA9IG93bmVyLmZvcm1hdHRlci5pbnB1dERpZ2l0KHBob25lTnVtYmVyLmNoYXJBdChpKSk7XG5cblx0ICAgICAgICAgICAgLy8gaGFzICgpLSBvciBzcGFjZSBpbnNpZGVcblx0ICAgICAgICAgICAgaWYgKC9bXFxzKCktXS9nLnRlc3QoY3VycmVudCkpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnQ7XG5cblx0ICAgICAgICAgICAgICAgIHZhbGlkYXRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJlbnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBlbHNlOiBvdmVyIGxlbmd0aCBpbnB1dFxuXHQgICAgICAgICAgICAgICAgLy8gaXQgdHVybnMgdG8gaW52YWxpZCBudW1iZXIgYWdhaW5cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHN0cmlwICgpXG5cdCAgICAgICAgLy8gZS5nLiBVUzogNzE2MTIzNDU2NyByZXR1cm5zICg3MTYpIDEyMy00NTY3XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1soKV0vZywgJycpO1xuXHQgICAgICAgIC8vIHJlcGxhY2UgbGlicmFyeSBkZWxpbWl0ZXIgd2l0aCB1c2VyIGN1c3RvbWl6ZWQgZGVsaW1pdGVyXG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1tcXHMtXS9nLCBvd25lci5kZWxpbWl0ZXIpO1xuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFBob25lRm9ybWF0dGVyO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBDcmVkaXRDYXJkRGV0ZWN0b3IgPSB7XG5cdCAgICBibG9ja3M6IHtcblx0ICAgICAgICB1YXRwOiBbNCwgNSwgNl0sXG5cdCAgICAgICAgYW1leDogWzQsIDYsIDVdLFxuXHQgICAgICAgIGRpbmVyczogWzQsIDYsIDRdLFxuXHQgICAgICAgIGRpc2NvdmVyOiBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgbWFzdGVyY2FyZDogWzQsIDQsIDQsIDRdLFxuXHQgICAgICAgIGRhbmtvcnQ6IFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICBpbnN0YXBheW1lbnQ6IFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICBqY2IxNTogWzQsIDYsIDVdLFxuXHQgICAgICAgIGpjYjogWzQsIDQsIDQsIDRdLFxuXHQgICAgICAgIG1hZXN0cm86IFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICB2aXNhOiBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgbWlyOiBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgdW5pb25QYXk6IFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICBnZW5lcmFsOiBbNCwgNCwgNCwgNF1cblx0ICAgIH0sXG5cblx0ICAgIHJlOiB7XG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggMTsgMTUgZGlnaXRzLCBub3Qgc3RhcnRzIHdpdGggMTgwMCAoamNiIGNhcmQpXG5cdCAgICAgICAgdWF0cDogL14oPyExODAwKTFcXGR7MCwxNH0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggMzQvMzc7IDE1IGRpZ2l0c1xuXHQgICAgICAgIGFtZXg6IC9eM1s0N11cXGR7MCwxM30vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggNjAxMS82NS82NDQtNjQ5OyAxNiBkaWdpdHNcblx0ICAgICAgICBkaXNjb3ZlcjogL14oPzo2MDExfDY1XFxkezAsMn18NjRbNC05XVxcZD8pXFxkezAsMTJ9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDMwMC0zMDUvMzA5IG9yIDM2LzM4LzM5OyAxNCBkaWdpdHNcblx0ICAgICAgICBkaW5lcnM6IC9eMyg/OjAoWzAtNV18OSl8WzY4OV1cXGQ/KVxcZHswLDExfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCA1MS01NS8yMjIx4oCTMjcyMDsgMTYgZGlnaXRzXG5cdCAgICAgICAgbWFzdGVyY2FyZDogL14oNVsxLTVdXFxkezAsMn18MjJbMi05XVxcZHswLDF9fDJbMy03XVxcZHswLDJ9KVxcZHswLDEyfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCA1MDE5LzQxNzUvNDU3MTsgMTYgZGlnaXRzXG5cdCAgICAgICAgZGFua29ydDogL14oNTAxOXw0MTc1fDQ1NzEpXFxkezAsMTJ9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDYzNy02Mzk7IDE2IGRpZ2l0c1xuXHQgICAgICAgIGluc3RhcGF5bWVudDogL142M1s3LTldXFxkezAsMTN9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDIxMzEvMTgwMDsgMTUgZGlnaXRzXG5cdCAgICAgICAgamNiMTU6IC9eKD86MjEzMXwxODAwKVxcZHswLDExfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCAyMTMxLzE4MDAvMzU7IDE2IGRpZ2l0c1xuXHQgICAgICAgIGpjYjogL14oPzozNVxcZHswLDJ9KVxcZHswLDEyfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCA1MC81Ni01OC82MzA0LzY3OyAxNiBkaWdpdHNcblx0ICAgICAgICBtYWVzdHJvOiAvXig/OjVbMDY3OF1cXGR7MCwyfXw2MzA0fDY3XFxkezAsMn0pXFxkezAsMTJ9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDIyOyAxNiBkaWdpdHNcblx0ICAgICAgICBtaXI6IC9eMjIwWzAtNF1cXGR7MCwxMn0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggNDsgMTYgZGlnaXRzXG5cdCAgICAgICAgdmlzYTogL140XFxkezAsMTV9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDYyLzgxOyAxNiBkaWdpdHNcblx0ICAgICAgICB1bmlvblBheTogL14oNjJ8ODEpXFxkezAsMTR9L1xuXHQgICAgfSxcblxuXHQgICAgZ2V0U3RyaWN0QmxvY2tzOiBmdW5jdGlvbiBnZXRTdHJpY3RCbG9ja3MoYmxvY2spIHtcblx0ICAgICAgICB2YXIgdG90YWwgPSBibG9jay5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXJyZW50O1xuXHQgICAgICAgIH0sIDApO1xuXG5cdCAgICAgICAgcmV0dXJuIGJsb2NrLmNvbmNhdCgxOSAtIHRvdGFsKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEluZm86IGZ1bmN0aW9uIGdldEluZm8odmFsdWUsIHN0cmljdE1vZGUpIHtcblx0ICAgICAgICB2YXIgYmxvY2tzID0gQ3JlZGl0Q2FyZERldGVjdG9yLmJsb2Nrcyxcblx0ICAgICAgICAgICAgcmUgPSBDcmVkaXRDYXJkRGV0ZWN0b3IucmU7XG5cblx0ICAgICAgICAvLyBTb21lIGNyZWRpdCBjYXJkIGNhbiBoYXZlIHVwIHRvIDE5IGRpZ2l0cyBudW1iZXIuXG5cdCAgICAgICAgLy8gU2V0IHN0cmljdE1vZGUgdG8gdHJ1ZSB3aWxsIHJlbW92ZSB0aGUgMTYgbWF4LWxlbmd0aCByZXN0cmFpbixcblx0ICAgICAgICAvLyBob3dldmVyLCBJIG5ldmVyIGZvdW5kIGFueSB3ZWJzaXRlIHZhbGlkYXRlIGNhcmQgbnVtYmVyIGxpa2Vcblx0ICAgICAgICAvLyB0aGlzLCBoZW5jZSBwcm9iYWJseSB5b3UgZG9uJ3Qgd2FudCB0byBlbmFibGUgdGhpcyBvcHRpb24uXG5cdCAgICAgICAgc3RyaWN0TW9kZSA9ICEhc3RyaWN0TW9kZTtcblxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiByZSkge1xuXHQgICAgICAgICAgICBpZiAocmVba2V5XS50ZXN0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWRCbG9ja3MgPSBibG9ja3Nba2V5XTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5LFxuXHQgICAgICAgICAgICAgICAgICAgIGJsb2Nrczogc3RyaWN0TW9kZSA/IHRoaXMuZ2V0U3RyaWN0QmxvY2tzKG1hdGNoZWRCbG9ja3MpIDogbWF0Y2hlZEJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHR5cGU6ICd1bmtub3duJyxcblx0ICAgICAgICAgICAgYmxvY2tzOiBzdHJpY3RNb2RlID8gdGhpcy5nZXRTdHJpY3RCbG9ja3MoYmxvY2tzLmdlbmVyYWwpIDogYmxvY2tzLmdlbmVyYWxcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ3JlZGl0Q2FyZERldGVjdG9yO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBVdGlsID0ge1xuXHQgICAgbm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9LFxuXG5cdCAgICBzdHJpcDogZnVuY3Rpb24gc3RyaXAodmFsdWUsIHJlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsICcnKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldFBvc3REZWxpbWl0ZXI6IGZ1bmN0aW9uIGdldFBvc3REZWxpbWl0ZXIodmFsdWUsIGRlbGltaXRlciwgZGVsaW1pdGVycykge1xuXHQgICAgICAgIC8vIHNpbmdsZSBkZWxpbWl0ZXJcblx0ICAgICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyID8gZGVsaW1pdGVyIDogJyc7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gbXVsdGlwbGUgZGVsaW1pdGVyc1xuXHQgICAgICAgIHZhciBtYXRjaGVkRGVsaW1pdGVyID0gJyc7XG5cdCAgICAgICAgZGVsaW1pdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50KSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtY3VycmVudC5sZW5ndGgpID09PSBjdXJyZW50KSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGVkRGVsaW1pdGVyID0gY3VycmVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgcmV0dXJuIG1hdGNoZWREZWxpbWl0ZXI7XG5cdCAgICB9LFxuXG5cdCAgICBnZXREZWxpbWl0ZXJSRUJ5RGVsaW1pdGVyOiBmdW5jdGlvbiBnZXREZWxpbWl0ZXJSRUJ5RGVsaW1pdGVyKGRlbGltaXRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGRlbGltaXRlci5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpLCAnZycpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0TmV4dEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbiBnZXROZXh0Q3Vyc29yUG9zaXRpb24ocHJldlBvcywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpIHtcblx0ICAgICAgICAvLyBJZiBjdXJzb3Igd2FzIGF0IHRoZSBlbmQgb2YgdmFsdWUsIGp1c3QgcGxhY2UgaXQgYmFjay5cblx0ICAgICAgICAvLyBCZWNhdXNlIG5ldyB2YWx1ZSBjb3VsZCBjb250YWluIGFkZGl0aW9uYWwgY2hhcnMuXG5cdCAgICAgICAgaWYgKG9sZFZhbHVlLmxlbmd0aCA9PT0gcHJldlBvcykge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWUubGVuZ3RoO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBwcmV2UG9zICsgdGhpcy5nZXRQb3NpdGlvbk9mZnNldChwcmV2UG9zLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGRlbGltaXRlciwgZGVsaW1pdGVycyk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRQb3NpdGlvbk9mZnNldDogZnVuY3Rpb24gZ2V0UG9zaXRpb25PZmZzZXQocHJldlBvcywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpIHtcblx0ICAgICAgICB2YXIgb2xkUmF3VmFsdWUsIG5ld1Jhd1ZhbHVlLCBsZW5ndGhPZmZzZXQ7XG5cblx0ICAgICAgICBvbGRSYXdWYWx1ZSA9IHRoaXMuc3RyaXBEZWxpbWl0ZXJzKG9sZFZhbHVlLnNsaWNlKDAsIHByZXZQb3MpLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpO1xuXHQgICAgICAgIG5ld1Jhd1ZhbHVlID0gdGhpcy5zdHJpcERlbGltaXRlcnMobmV3VmFsdWUuc2xpY2UoMCwgcHJldlBvcyksIGRlbGltaXRlciwgZGVsaW1pdGVycyk7XG5cdCAgICAgICAgbGVuZ3RoT2Zmc2V0ID0gb2xkUmF3VmFsdWUubGVuZ3RoIC0gbmV3UmF3VmFsdWUubGVuZ3RoO1xuXG5cdCAgICAgICAgcmV0dXJuIGxlbmd0aE9mZnNldCAhPT0gMCA/IGxlbmd0aE9mZnNldCAvIE1hdGguYWJzKGxlbmd0aE9mZnNldCkgOiAwO1xuXHQgICAgfSxcblxuXHQgICAgc3RyaXBEZWxpbWl0ZXJzOiBmdW5jdGlvbiBzdHJpcERlbGltaXRlcnModmFsdWUsIGRlbGltaXRlciwgZGVsaW1pdGVycykge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXM7XG5cblx0ICAgICAgICAvLyBzaW5nbGUgZGVsaW1pdGVyXG5cdCAgICAgICAgaWYgKGRlbGltaXRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHZhciBkZWxpbWl0ZXJSRSA9IGRlbGltaXRlciA/IG93bmVyLmdldERlbGltaXRlclJFQnlEZWxpbWl0ZXIoZGVsaW1pdGVyKSA6ICcnO1xuXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGRlbGltaXRlclJFLCAnJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gbXVsdGlwbGUgZGVsaW1pdGVyc1xuXHQgICAgICAgIGRlbGltaXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCkge1xuXHQgICAgICAgICAgICBjdXJyZW50LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShvd25lci5nZXREZWxpbWl0ZXJSRUJ5RGVsaW1pdGVyKGxldHRlciksICcnKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9LFxuXG5cdCAgICBoZWFkU3RyOiBmdW5jdGlvbiBoZWFkU3RyKHN0ciwgbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0ci5zbGljZSgwLCBsZW5ndGgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0TWF4TGVuZ3RoOiBmdW5jdGlvbiBnZXRNYXhMZW5ndGgoYmxvY2tzKSB7XG5cdCAgICAgICAgcmV0dXJuIGJsb2Nrcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIGN1cnJlbnQ7XG5cdCAgICAgICAgfSwgMCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBzdHJpcCBwcmVmaXhcblx0ICAgIC8vIEJlZm9yZSB0eXBlICB8ICAgQWZ0ZXIgdHlwZSAgICB8ICAgICBSZXR1cm4gdmFsdWVcblx0ICAgIC8vIFBFRklYLS4uLiAgICB8ICAgUEVGSVgtLi4uICAgICB8ICAgICAnJ1xuXHQgICAgLy8gUFJFRklYLTEyMyAgIHwgICBQRUZJWC0xMjMgICAgIHwgICAgIDEyM1xuXHQgICAgLy8gUFJFRklYLTEyMyAgIHwgICBQUkVGSVgtMjMgICAgIHwgICAgIDIzXG5cdCAgICAvLyBQUkVGSVgtMTIzICAgfCAgIFBSRUZJWC0xMjM0ICAgfCAgICAgMTIzNFxuXHQgICAgZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZTogZnVuY3Rpb24gZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZSh2YWx1ZSwgcHJlZml4LCBwcmVmaXhMZW5ndGgsIHByZXZSZXN1bHQsIGRlbGltaXRlciwgZGVsaW1pdGVycywgbm9JbW1lZGlhdGVQcmVmaXgsIHRhaWxQcmVmaXgsIHNpZ25CZWZvcmVQcmVmaXgpIHtcblx0ICAgICAgICAvLyBObyBwcmVmaXhcblx0ICAgICAgICBpZiAocHJlZml4TGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBWYWx1ZSBpcyBwcmVmaXhcblx0ICAgICAgICBpZiAodmFsdWUgPT09IHByZWZpeCAmJiB2YWx1ZSAhPT0gJycpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICcnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChzaWduQmVmb3JlUHJlZml4ICYmIHZhbHVlLnNsaWNlKDAsIDEpID09ICctJykge1xuXHQgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZSZXN1bHQuc2xpY2UoMCwgMSkgPT0gJy0nID8gcHJldlJlc3VsdC5zbGljZSgxKSA6IHByZXZSZXN1bHQ7XG5cdCAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLmdldFByZWZpeFN0cmlwcGVkVmFsdWUodmFsdWUuc2xpY2UoMSksIHByZWZpeCwgcHJlZml4TGVuZ3RoLCBwcmV2LCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMsIG5vSW1tZWRpYXRlUHJlZml4LCB0YWlsUHJlZml4LCBzaWduQmVmb3JlUHJlZml4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmUgcmVzdWx0IHByZWZpeCBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggcHJlLWRlZmluZWQgcHJlZml4XG5cdCAgICAgICAgaWYgKHByZXZSZXN1bHQuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSAhPT0gcHJlZml4ICYmICF0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aW1lIHVzZXIgZW50ZXJlZCBzb21ldGhpbmdcblx0ICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9IGVsc2UgaWYgKHByZXZSZXN1bHQuc2xpY2UoLXByZWZpeExlbmd0aCkgIT09IHByZWZpeCAmJiB0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aW1lIHVzZXIgZW50ZXJlZCBzb21ldGhpbmdcblx0ICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5zdHJpcERlbGltaXRlcnMocHJldlJlc3VsdCwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKTtcblxuXHQgICAgICAgIC8vIE5ldyB2YWx1ZSBoYXMgaXNzdWUsIHNvbWVvbmUgdHlwZWQgaW4gYmV0d2VlbiBwcmVmaXggbGV0dGVyc1xuXHQgICAgICAgIC8vIFJldmVydCB0byBwcmUgdmFsdWVcblx0ICAgICAgICBpZiAodmFsdWUuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSAhPT0gcHJlZml4ICYmICF0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcmV2VmFsdWUuc2xpY2UocHJlZml4TGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnNsaWNlKC1wcmVmaXhMZW5ndGgpICE9PSBwcmVmaXggJiYgdGFpbFByZWZpeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJldlZhbHVlLnNsaWNlKDAsIC1wcmVmaXhMZW5ndGggLSAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBObyBpc3N1ZSwgc3RyaXAgcHJlZml4IGZvciBuZXcgdmFsdWVcblx0ICAgICAgICByZXR1cm4gdGFpbFByZWZpeCA/IHZhbHVlLnNsaWNlKDAsIC1wcmVmaXhMZW5ndGgpIDogdmFsdWUuc2xpY2UocHJlZml4TGVuZ3RoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpcnN0RGlmZkluZGV4OiBmdW5jdGlvbiBnZXRGaXJzdERpZmZJbmRleChwcmV2LCBjdXJyZW50KSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gMDtcblxuXHQgICAgICAgIHdoaWxlIChwcmV2LmNoYXJBdChpbmRleCkgPT09IGN1cnJlbnQuY2hhckF0KGluZGV4KSkge1xuXHQgICAgICAgICAgICBpZiAocHJldi5jaGFyQXQoaW5kZXgrKykgPT09ICcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVmFsdWUodmFsdWUsIGJsb2NrcywgYmxvY2tzTGVuZ3RoLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMsIGRlbGltaXRlckxhenlTaG93KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuXHQgICAgICAgICAgICBtdWx0aXBsZURlbGltaXRlcnMgPSBkZWxpbWl0ZXJzLmxlbmd0aCA+IDAsXG5cdCAgICAgICAgICAgIGN1cnJlbnREZWxpbWl0ZXIgPSAnJztcblxuXHQgICAgICAgIC8vIG5vIG9wdGlvbnMsIG5vcm1hbCBpbnB1dFxuXHQgICAgICAgIGlmIChibG9ja3NMZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcblx0ICAgICAgICAgICAgICAgICAgICByZXN0ID0gdmFsdWUuc2xpY2UobGVuZ3RoKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlRGVsaW1pdGVycykge1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxpbWl0ZXIgPSBkZWxpbWl0ZXJzW2RlbGltaXRlckxhenlTaG93ID8gaW5kZXggLSAxIDogaW5kZXhdIHx8IGN1cnJlbnREZWxpbWl0ZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxpbWl0ZXIgPSBkZWxpbWl0ZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChkZWxpbWl0ZXJMYXp5U2hvdykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnREZWxpbWl0ZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN1Yjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN1YjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWIubGVuZ3RoID09PSBsZW5ndGggJiYgaW5kZXggPCBibG9ja3NMZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50RGVsaW1pdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHJlbWFpbmluZyBzdHJpbmdcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0sXG5cblx0ICAgIC8vIG1vdmUgY3Vyc29yIHRvIHRoZSBlbmRcblx0ICAgIC8vIHRoZSBmaXJzdCB0aW1lIHVzZXIgZm9jdXNlcyBvbiBhbiBpbnB1dCB3aXRoIHByZWZpeFxuXHQgICAgZml4UHJlZml4Q3Vyc29yOiBmdW5jdGlvbiBmaXhQcmVmaXhDdXJzb3IoZWwsIHByZWZpeCwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG5cdCAgICAgICAgaWYgKCFlbCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHZhbCA9IGVsLnZhbHVlLFxuXHQgICAgICAgICAgICBhcHBlbmRpeCA9IGRlbGltaXRlciB8fCBkZWxpbWl0ZXJzWzBdIHx8ICcgJztcblxuXHQgICAgICAgIGlmICghZWwuc2V0U2VsZWN0aW9uUmFuZ2UgfHwgIXByZWZpeCB8fCBwcmVmaXgubGVuZ3RoICsgYXBwZW5kaXgubGVuZ3RoIDw9IHZhbC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoICogMjtcblxuXHQgICAgICAgIC8vIHNldCB0aW1lb3V0IHRvIGF2b2lkIGJsaW5rXG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGVsLnNldFNlbGVjdGlvblJhbmdlKGxlbiwgbGVuKTtcblx0ICAgICAgICB9LCAxKTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIENoZWNrIGlmIGlucHV0IGZpZWxkIGlzIGZ1bGx5IHNlbGVjdGVkXG5cdCAgICBjaGVja0Z1bGxTZWxlY3Rpb246IGZ1bmN0aW9uIGNoZWNrRnVsbFNlbGVjdGlvbih2YWx1ZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgfHwgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkgfHwge307XG5cdCAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcblx0ICAgICAgICB9IGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICAvLyBJZ25vcmVcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihlbGVtZW50LCBwb3NpdGlvbiwgZG9jKSB7XG5cdCAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBjdXJzb3IgaXMgYWxyZWFkeSBpbiB0aGUgZW5kXG5cdCAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC52YWx1ZS5sZW5ndGggPD0gcG9zaXRpb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSgpO1xuXG5cdCAgICAgICAgICAgIHJhbmdlLm1vdmUoJ2NoYXJhY3RlcicsIHBvc2l0aW9uKTtcblx0ICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBpbnB1dCBlbGVtZW50IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBzZWxlY3Rpb24nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIGdldEFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQocGFyZW50KSB7XG5cdCAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBwYXJlbnQuYWN0aXZlRWxlbWVudDtcblx0ICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlRWxlbWVudChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcblx0ICAgIH0sXG5cblx0ICAgIGlzQW5kcm9pZDogZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuXHQgICAgICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gT24gQW5kcm9pZCBjaHJvbWUsIHRoZSBrZXl1cCBhbmQga2V5ZG93biBldmVudHNcblx0ICAgIC8vIGFsd2F5cyByZXR1cm4ga2V5IGNvZGUgMjI5IGFzIGEgY29tcG9zaXRpb24gdGhhdFxuXHQgICAgLy8gYnVmZmVycyB0aGUgdXNlcuKAmXMga2V5c3Ryb2tlc1xuXHQgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3Npci9jbGVhdmUuanMvaXNzdWVzLzE0N1xuXHQgICAgaXNBbmRyb2lkQmFja3NwYWNlS2V5ZG93bjogZnVuY3Rpb24gaXNBbmRyb2lkQmFja3NwYWNlS2V5ZG93bihsYXN0SW5wdXRWYWx1ZSwgY3VycmVudElucHV0VmFsdWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuaXNBbmRyb2lkKCkgfHwgIWxhc3RJbnB1dFZhbHVlIHx8ICFjdXJyZW50SW5wdXRWYWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnB1dFZhbHVlID09PSBsYXN0SW5wdXRWYWx1ZS5zbGljZSgwLCAtMSk7XG5cdCAgICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBQcm9wcyBBc3NpZ25tZW50XG5cdCAqXG5cdCAqIFNlcGFyYXRlIHRoaXMsIHNvIHJlYWN0IG1vZHVsZSBjYW4gc2hhcmUgdGhlIHVzYWdlXG5cdCAqL1xuXG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHR2YXIgRGVmYXVsdFByb3BlcnRpZXMgPSB7XG5cdCAgICAvLyBNYXliZSBjaGFuZ2UgdG8gb2JqZWN0LWFzc2lnblxuXHQgICAgLy8gZm9yIG5vdyBqdXN0IGtlZXAgaXQgYXMgc2ltcGxlXG5cdCAgICBhc3NpZ246IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIG9wdHMpIHtcblx0ICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cdCAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICAgICAgICAvLyBjcmVkaXQgY2FyZFxuXHQgICAgICAgIHRhcmdldC5jcmVkaXRDYXJkID0gISFvcHRzLmNyZWRpdENhcmQ7XG5cdCAgICAgICAgdGFyZ2V0LmNyZWRpdENhcmRTdHJpY3RNb2RlID0gISFvcHRzLmNyZWRpdENhcmRTdHJpY3RNb2RlO1xuXHQgICAgICAgIHRhcmdldC5jcmVkaXRDYXJkVHlwZSA9ICcnO1xuXHQgICAgICAgIHRhcmdldC5vbkNyZWRpdENhcmRUeXBlQ2hhbmdlZCA9IG9wdHMub25DcmVkaXRDYXJkVHlwZUNoYW5nZWQgfHwgZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgICAvLyBwaG9uZVxuXHQgICAgICAgIHRhcmdldC5waG9uZSA9ICEhb3B0cy5waG9uZTtcblx0ICAgICAgICB0YXJnZXQucGhvbmVSZWdpb25Db2RlID0gb3B0cy5waG9uZVJlZ2lvbkNvZGUgfHwgJ0FVJztcblx0ICAgICAgICB0YXJnZXQucGhvbmVGb3JtYXR0ZXIgPSB7fTtcblxuXHQgICAgICAgIC8vIHRpbWVcblx0ICAgICAgICB0YXJnZXQudGltZSA9ICEhb3B0cy50aW1lO1xuXHQgICAgICAgIHRhcmdldC50aW1lUGF0dGVybiA9IG9wdHMudGltZVBhdHRlcm4gfHwgWydoJywgJ20nLCAncyddO1xuXHQgICAgICAgIHRhcmdldC50aW1lRm9ybWF0ID0gb3B0cy50aW1lRm9ybWF0IHx8ICcyNCc7XG5cdCAgICAgICAgdGFyZ2V0LnRpbWVGb3JtYXR0ZXIgPSB7fTtcblxuXHQgICAgICAgIC8vIGRhdGVcblx0ICAgICAgICB0YXJnZXQuZGF0ZSA9ICEhb3B0cy5kYXRlO1xuXHQgICAgICAgIHRhcmdldC5kYXRlUGF0dGVybiA9IG9wdHMuZGF0ZVBhdHRlcm4gfHwgWydkJywgJ20nLCAnWSddO1xuXHQgICAgICAgIHRhcmdldC5kYXRlTWluID0gb3B0cy5kYXRlTWluIHx8ICcnO1xuXHQgICAgICAgIHRhcmdldC5kYXRlTWF4ID0gb3B0cy5kYXRlTWF4IHx8ICcnO1xuXHQgICAgICAgIHRhcmdldC5kYXRlRm9ybWF0dGVyID0ge307XG5cblx0ICAgICAgICAvLyBudW1lcmFsXG5cdCAgICAgICAgdGFyZ2V0Lm51bWVyYWwgPSAhIW9wdHMubnVtZXJhbDtcblx0ICAgICAgICB0YXJnZXQubnVtZXJhbEludGVnZXJTY2FsZSA9IG9wdHMubnVtZXJhbEludGVnZXJTY2FsZSA+IDAgPyBvcHRzLm51bWVyYWxJbnRlZ2VyU2NhbGUgOiAwO1xuXHQgICAgICAgIHRhcmdldC5udW1lcmFsRGVjaW1hbFNjYWxlID0gb3B0cy5udW1lcmFsRGVjaW1hbFNjYWxlID49IDAgPyBvcHRzLm51bWVyYWxEZWNpbWFsU2NhbGUgOiAyO1xuXHQgICAgICAgIHRhcmdldC5udW1lcmFsRGVjaW1hbE1hcmsgPSBvcHRzLm51bWVyYWxEZWNpbWFsTWFyayB8fCAnLic7XG5cdCAgICAgICAgdGFyZ2V0Lm51bWVyYWxUaG91c2FuZHNHcm91cFN0eWxlID0gb3B0cy5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSB8fCAndGhvdXNhbmQnO1xuXHQgICAgICAgIHRhcmdldC5udW1lcmFsUG9zaXRpdmVPbmx5ID0gISFvcHRzLm51bWVyYWxQb3NpdGl2ZU9ubHk7XG5cdCAgICAgICAgdGFyZ2V0LnN0cmlwTGVhZGluZ1plcm9lcyA9IG9wdHMuc3RyaXBMZWFkaW5nWmVyb2VzICE9PSBmYWxzZTtcblx0ICAgICAgICB0YXJnZXQuc2lnbkJlZm9yZVByZWZpeCA9ICEhb3B0cy5zaWduQmVmb3JlUHJlZml4O1xuXHQgICAgICAgIHRhcmdldC50YWlsUHJlZml4ID0gISFvcHRzLnRhaWxQcmVmaXg7XG5cblx0ICAgICAgICAvLyBvdGhlcnNcblx0ICAgICAgICB0YXJnZXQuc3dhcEhpZGRlbklucHV0ID0gISFvcHRzLnN3YXBIaWRkZW5JbnB1dDtcblxuXHQgICAgICAgIHRhcmdldC5udW1lcmljT25seSA9IHRhcmdldC5jcmVkaXRDYXJkIHx8IHRhcmdldC5kYXRlIHx8ICEhb3B0cy5udW1lcmljT25seTtcblxuXHQgICAgICAgIHRhcmdldC51cHBlcmNhc2UgPSAhIW9wdHMudXBwZXJjYXNlO1xuXHQgICAgICAgIHRhcmdldC5sb3dlcmNhc2UgPSAhIW9wdHMubG93ZXJjYXNlO1xuXG5cdCAgICAgICAgdGFyZ2V0LnByZWZpeCA9IHRhcmdldC5jcmVkaXRDYXJkIHx8IHRhcmdldC5kYXRlID8gJycgOiBvcHRzLnByZWZpeCB8fCAnJztcblx0ICAgICAgICB0YXJnZXQubm9JbW1lZGlhdGVQcmVmaXggPSAhIW9wdHMubm9JbW1lZGlhdGVQcmVmaXg7XG5cdCAgICAgICAgdGFyZ2V0LnByZWZpeExlbmd0aCA9IHRhcmdldC5wcmVmaXgubGVuZ3RoO1xuXHQgICAgICAgIHRhcmdldC5yYXdWYWx1ZVRyaW1QcmVmaXggPSAhIW9wdHMucmF3VmFsdWVUcmltUHJlZml4O1xuXHQgICAgICAgIHRhcmdldC5jb3B5RGVsaW1pdGVyID0gISFvcHRzLmNvcHlEZWxpbWl0ZXI7XG5cblx0ICAgICAgICB0YXJnZXQuaW5pdFZhbHVlID0gb3B0cy5pbml0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmluaXRWYWx1ZSAhPT0gbnVsbCA/IG9wdHMuaW5pdFZhbHVlLnRvU3RyaW5nKCkgOiAnJztcblxuXHQgICAgICAgIHRhcmdldC5kZWxpbWl0ZXIgPSBvcHRzLmRlbGltaXRlciB8fCBvcHRzLmRlbGltaXRlciA9PT0gJycgPyBvcHRzLmRlbGltaXRlciA6IG9wdHMuZGF0ZSA/ICcvJyA6IG9wdHMudGltZSA/ICc6JyA6IG9wdHMubnVtZXJhbCA/ICcsJyA6IG9wdHMucGhvbmUgPyAnICcgOiAnICc7XG5cdCAgICAgICAgdGFyZ2V0LmRlbGltaXRlckxlbmd0aCA9IHRhcmdldC5kZWxpbWl0ZXIubGVuZ3RoO1xuXHQgICAgICAgIHRhcmdldC5kZWxpbWl0ZXJMYXp5U2hvdyA9ICEhb3B0cy5kZWxpbWl0ZXJMYXp5U2hvdztcblx0ICAgICAgICB0YXJnZXQuZGVsaW1pdGVycyA9IG9wdHMuZGVsaW1pdGVycyB8fCBbXTtcblxuXHQgICAgICAgIHRhcmdldC5ibG9ja3MgPSBvcHRzLmJsb2NrcyB8fCBbXTtcblx0ICAgICAgICB0YXJnZXQuYmxvY2tzTGVuZ3RoID0gdGFyZ2V0LmJsb2Nrcy5sZW5ndGg7XG5cblx0ICAgICAgICB0YXJnZXQucm9vdCA9ICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihnbG9iYWwpKSA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsID8gZ2xvYmFsIDogd2luZG93O1xuXHQgICAgICAgIHRhcmdldC5kb2N1bWVudCA9IG9wdHMuZG9jdW1lbnQgfHwgdGFyZ2V0LnJvb3QuZG9jdW1lbnQ7XG5cblx0ICAgICAgICB0YXJnZXQubWF4TGVuZ3RoID0gMDtcblxuXHQgICAgICAgIHRhcmdldC5iYWNrc3BhY2UgPSBmYWxzZTtcblx0ICAgICAgICB0YXJnZXQucmVzdWx0ID0gJyc7XG5cblx0ICAgICAgICB0YXJnZXQub25WYWx1ZUNoYW5nZWQgPSBvcHRzLm9uVmFsdWVDaGFuZ2VkIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5cdCAgICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRQcm9wZXJ0aWVzO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaWQiLCJsb2FkZWQiLCJjYWxsIiwibSIsImMiLCJwIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJvYmoiLCJrZXlzIiwiaW5kZXhPZiIsIlJlYWN0IiwiQ3JlYXRlUmVhY3RDbGFzcyIsIk51bWVyYWxGb3JtYXR0ZXIiLCJEYXRlRm9ybWF0dGVyIiwiVGltZUZvcm1hdHRlciIsIlBob25lRm9ybWF0dGVyIiwiQ3JlZGl0Q2FyZERldGVjdG9yIiwiVXRpbCIsIkRlZmF1bHRQcm9wZXJ0aWVzIiwiY2xlYXZlUmVhY3RDbGFzcyIsImNvbXBvbmVudERpZE1vdW50IiwiaW5pdCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsIm93bmVyIiwicGhvbmVSZWdpb25Db2RlIiwicHJvcHMiLCJvcHRpb25zIiwibmV3VmFsdWUiLCJ2YWx1ZSIsInBwcyIsInByb3BlcnRpZXMiLCJ1cGRhdGVSZWdpc3RlcmVkRXZlbnRzIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJyZXN1bHQiLCJpbml0VmFsdWUiLCJvbklucHV0IiwicHJldlBob25lUmVnaW9uQ29kZSIsImluaXRQaG9uZUZvcm1hdHRlciIsInNldFNlbGVjdGlvbiIsImVsZW1lbnQiLCJzdGF0ZSIsImN1cnNvclBvc2l0aW9uIiwiZG9jdW1lbnQiLCJfb3duZXIkcmVnaXN0ZXJlZEV2ZW4iLCJyZWdpc3RlcmVkRXZlbnRzIiwib25LZXlEb3duIiwib25DaGFuZ2UiLCJvbkZvY3VzIiwib25CbHVyIiwib25Jbml0IiwiZ2V0SW5pdGlhbFN0YXRlIiwiX293bmVyJHByb3BzIiwibm9vcCIsIm51bWVyYWwiLCJwaG9uZSIsImNyZWRpdENhcmQiLCJ0aW1lIiwiZGF0ZSIsImJsb2Nrc0xlbmd0aCIsInByZWZpeCIsIm1heExlbmd0aCIsImdldE1heExlbmd0aCIsImJsb2NrcyIsImlzQW5kcm9pZCIsImluaXREYXRlRm9ybWF0dGVyIiwiaW5pdFRpbWVGb3JtYXR0ZXIiLCJpbml0TnVtZXJhbEZvcm1hdHRlciIsIm5vSW1tZWRpYXRlUHJlZml4IiwibnVtZXJhbEZvcm1hdHRlciIsIm51bWVyYWxEZWNpbWFsTWFyayIsIm51bWVyYWxJbnRlZ2VyU2NhbGUiLCJudW1lcmFsRGVjaW1hbFNjYWxlIiwibnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUiLCJudW1lcmFsUG9zaXRpdmVPbmx5Iiwic3RyaXBMZWFkaW5nWmVyb2VzIiwic2lnbkJlZm9yZVByZWZpeCIsInRhaWxQcmVmaXgiLCJkZWxpbWl0ZXIiLCJ0aW1lRm9ybWF0dGVyIiwidGltZVBhdHRlcm4iLCJ0aW1lRm9ybWF0IiwiZ2V0QmxvY2tzIiwiZGF0ZUZvcm1hdHRlciIsImRhdGVQYXR0ZXJuIiwiZGF0ZU1pbiIsImRhdGVNYXgiLCJwaG9uZUZvcm1hdHRlciIsIkNsZWF2ZSIsIkFzWW91VHlwZUZvcm1hdHRlciIsImV4IiwiRXJyb3IiLCJzZXRSYXdWYWx1ZSIsInJlcGxhY2UiLCJwb3N0RGVsaW1pdGVyQmFja3NwYWNlIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0IiwiZ2V0UmF3VmFsdWUiLCJyYXdWYWx1ZSIsInJhd1ZhbHVlVHJpbVByZWZpeCIsImdldFByZWZpeFN0cmlwcGVkVmFsdWUiLCJwcmVmaXhMZW5ndGgiLCJkZWxpbWl0ZXJzIiwic3RyaXBEZWxpbWl0ZXJzIiwiZ2V0SVNPRm9ybWF0RGF0ZSIsImdldElTT0Zvcm1hdFRpbWUiLCJldmVudCIsImNoYXJDb2RlIiwid2hpY2giLCJrZXlDb2RlIiwibGFzdElucHV0VmFsdWUiLCJpc0JhY2t3YXJkIiwiZml4UHJlZml4Q3Vyc29yIiwiaW5wdXRUeXBlIiwicG9zdERlbGltaXRlciIsImdldFBvc3REZWxpbWl0ZXIiLCJmcm9tUHJvcHMiLCJwb3N0RGVsaW1pdGVyQWZ0ZXIiLCJoZWFkU3RyIiwiZm9ybWF0Iiwic2xpY2UiLCJ1cGRhdGVWYWx1ZVN0YXRlIiwiZ2V0VmFsaWRhdGVkRGF0ZSIsImdldFZhbGlkYXRlZFRpbWUiLCJudW1lcmljT25seSIsInN0cmlwIiwidXBwZXJjYXNlIiwidG9VcHBlckNhc2UiLCJsb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsInVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWUiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImRlbGltaXRlckxhenlTaG93IiwiY3JlZGl0Q2FyZEluZm8iLCJnZXRJbmZvIiwiY3JlZGl0Q2FyZFN0cmljdE1vZGUiLCJjcmVkaXRDYXJkVHlwZSIsInR5cGUiLCJvbkNyZWRpdENhcmRUeXBlQ2hhbmdlZCIsInNldFN0YXRlIiwiZW5kUG9zIiwic2VsZWN0aW9uRW5kIiwib2xkVmFsdWUiLCJnZXROZXh0Q3Vyc29yUG9zaXRpb24iLCJ3aW5kb3ciLCJzZXRUaW1lb3V0IiwicmVuZGVyIiwiX293bmVyJHByb3BzMiIsImh0bWxSZWYiLCJwcm9wc1RvVHJhbnNmZXIiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiX3JlZiIsImFwcGx5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJDb21wb25lbnQiLCJ1cGRhdGVyIiwiaXNWYWxpZEVsZW1lbnQiLCJfYXNzaWduIiwiZW1wdHlPYmplY3QiLCJfaW52YXJpYW50IiwicHJvY2VzcyIsIndhcm5pbmciLCJNSVhJTlNfS0VZIiwiaWRlbnRpdHkiLCJmbiIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzIiwicHJvcCIsImNvbnRleHQiLCJjaGlsZENvbnRleHQiLCJSZWFjdENvbXBvbmVudCIsImluamVjdGVkTWl4aW5zIiwiUmVhY3RDbGFzc0ludGVyZmFjZSIsIm1peGlucyIsInN0YXRpY3MiLCJwcm9wVHlwZXMiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsImdldENoaWxkQ29udGV4dCIsImNvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIlJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJSRVNFUlZFRF9TUEVDX0tFWVMiLCJkaXNwbGF5TmFtZSIsIkNvbnN0cnVjdG9yIiwibWl4U3BlY0ludG9Db21wb25lbnQiLCJ2YWxpZGF0ZVR5cGVEZWYiLCJjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbiIsIm1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50IiwiYXV0b2JpbmQiLCJ0eXBlRGVmIiwibG9jYXRpb24iLCJwcm9wTmFtZSIsInZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUiLCJpc0FscmVhZHlEZWZpbmVkIiwibmFtZSIsInNwZWNQb2xpY3kiLCJSZWFjdENsYXNzTWl4aW4iLCJzcGVjIiwidHlwZW9mU3BlYyIsImlzTWl4aW5WYWxpZCIsInByb3RvIiwiYXV0b0JpbmRQYWlycyIsIl9fcmVhY3RBdXRvQmluZFBhaXJzIiwicHJvcGVydHkiLCJpc1JlYWN0Q2xhc3NNZXRob2QiLCJpc0Z1bmN0aW9uIiwic2hvdWxkQXV0b0JpbmQiLCJwdXNoIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsIm1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMiLCJvbmUiLCJ0d28iLCJtZXJnZWRSZXN1bHQiLCJhIiwiYiIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImNvbXBvbmVudCIsIm1ldGhvZCIsImJvdW5kTWV0aG9kIiwiYmluZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJjb21wb25lbnROYW1lIiwiY29uc3RydWN0b3IiLCJfYmluZCIsIm5ld1RoaXMiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsInJlYm91bmRNZXRob2QiLCJiaW5kQXV0b0JpbmRNZXRob2RzIiwicGFpcnMiLCJhdXRvQmluZEtleSIsIklzTW91bnRlZFByZU1peGluIiwiX19pc01vdW50ZWQiLCJJc01vdW50ZWRQb3N0TWl4aW4iLCJyZXBsYWNlU3RhdGUiLCJuZXdTdGF0ZSIsImNhbGxiYWNrIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImlzTW91bnRlZCIsIl9fZGlkV2FybklzTW91bnRlZCIsIlJlYWN0Q2xhc3NDb21wb25lbnQiLCJjcmVhdGVDbGFzcyIsInJlZnMiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc0FycmF5IiwiZm9yRWFjaCIsImRlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwibWV0aG9kTmFtZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJlcnIiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImZyZWV6ZSIsInZhbGlkYXRlRm9ybWF0IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiZCIsImUiLCJmIiwiZXJyb3IiLCJhcmdJbmRleCIsImZyYW1lc1RvUG9wIiwiZW1wdHlGdW5jdGlvbiIsInByaW50V2FybmluZyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwieCIsIl9sZW4yIiwiX2tleTIiLCJjb25jYXQiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImFyZyIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zTnVsbCIsInRoYXRSZXR1cm5zVGhpcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJncm91cFN0eWxlIiwidGhvdXNhbmQiLCJkZWxpbWl0ZXJSRSIsIlJlZ0V4cCIsImxha2giLCJ3YW4iLCJub25lIiwicGFydHMiLCJwYXJ0U2lnbiIsInBhcnRTaWduQW5kUHJlZml4IiwicGFydEludGVnZXIiLCJwYXJ0RGVjaW1hbCIsInJldmVyc2UiLCJwYXJzZUludCIsInVuc2hpZnQiLCJpbml0QmxvY2tzIiwiYWRkTGVhZGluZ1plcm8iLCJpbmRleCIsInN1YiIsInN1YjAiLCJyZXN0IiwiZ2V0Rml4ZWREYXRlU3RyaW5nIiwiZGF5SW5kZXgiLCJtb250aEluZGV4IiwieWVhckluZGV4IiwiZGF5U3RhcnRJbmRleCIsIm1vbnRoU3RhcnRJbmRleCIsInllYXJTdGFydEluZGV4IiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwiZnVsbFllYXJEb25lIiwiZ2V0Rml4ZWREYXRlIiwiZ2V0UmFuZ2VGaXhlZERhdGUiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJhZGRMZWFkaW5nWmVyb0ZvclllYXIiLCJmaW5kIiwiTWF0aCIsIm1pbiIsImlzTGVhcFllYXIiLCJudW1iZXIiLCJmdWxsWWVhck1vZGUiLCJnZXRUaW1lRm9ybWF0T3B0aW9ucyIsIm1heEhvdXJGaXJzdERpZ2l0IiwibWF4SG91cnMiLCJtYXhNaW51dGVzRmlyc3REaWdpdCIsIm1heE1pbnV0ZXMiLCJ0aW1lRm9ybWF0T3B0aW9ucyIsImdldEZpeGVkVGltZVN0cmluZyIsInNlY29uZEluZGV4IiwibWludXRlSW5kZXgiLCJob3VySW5kZXgiLCJzZWNvbmRTdGFydEluZGV4IiwibWludXRlU3RhcnRJbmRleCIsImhvdXJTdGFydEluZGV4Iiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImdldEZpeGVkVGltZSIsImZvcm1hdHRlciIsInNldEZvcm1hdHRlciIsInBob25lTnVtYmVyIiwiY2xlYXIiLCJ2YWxpZGF0ZWQiLCJpTWF4IiwiaW5wdXREaWdpdCIsImNoYXJBdCIsInRlc3QiLCJ1YXRwIiwiYW1leCIsImRpbmVycyIsImRpc2NvdmVyIiwibWFzdGVyY2FyZCIsImRhbmtvcnQiLCJpbnN0YXBheW1lbnQiLCJqY2IxNSIsImpjYiIsIm1hZXN0cm8iLCJ2aXNhIiwibWlyIiwidW5pb25QYXkiLCJnZW5lcmFsIiwicmUiLCJnZXRTdHJpY3RCbG9ja3MiLCJibG9jayIsInRvdGFsIiwicHJldiIsInN0cmljdE1vZGUiLCJtYXRjaGVkQmxvY2tzIiwibWF0Y2hlZERlbGltaXRlciIsImdldERlbGltaXRlclJFQnlEZWxpbWl0ZXIiLCJwcmV2UG9zIiwiZ2V0UG9zaXRpb25PZmZzZXQiLCJvbGRSYXdWYWx1ZSIsIm5ld1Jhd1ZhbHVlIiwibGVuZ3RoT2Zmc2V0IiwiYWJzIiwic3RyIiwicHJldlJlc3VsdCIsInByZXZWYWx1ZSIsImdldEZpcnN0RGlmZkluZGV4IiwibXVsdGlwbGVEZWxpbWl0ZXJzIiwiY3VycmVudERlbGltaXRlciIsImVsIiwiYXBwZW5kaXgiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImxlbiIsImNoZWNrRnVsbFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsInBvc2l0aW9uIiwiZG9jIiwiZ2V0QWN0aXZlRWxlbWVudCIsImNyZWF0ZVRleHRSYW5nZSIsInJhbmdlIiwibW92ZSIsInNlbGVjdCIsIndhcm4iLCJwYXJlbnQiLCJhY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzQW5kcm9pZEJhY2tzcGFjZUtleWRvd24iLCJjdXJyZW50SW5wdXRWYWx1ZSIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9wdHMiLCJzd2FwSGlkZGVuSW5wdXQiLCJjb3B5RGVsaW1pdGVyIiwiZGVsaW1pdGVyTGVuZ3RoIiwiZ2xvYmFsIiwiYmFja3NwYWNlIiwib25WYWx1ZUNoYW5nZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/cleave.js/dist/cleave-react-node.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/cleave.js/react.js":
/*!******************************************!*\
  !*** ../node_modules/cleave.js/react.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/cleave-react-node.js */ \"(ssr)/../node_modules/cleave.js/dist/cleave-react-node.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2NsZWF2ZS5qcy9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsb0lBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9jbGVhdmUuanMvcmVhY3QuanM/MDEwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGVhdmUtcmVhY3Qtbm9kZS5qcycpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/cleave.js/react.js\n");

/***/ })

};
;